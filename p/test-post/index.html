<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='试着去理解虚拟DOM'><title>试着去理解虚拟DOM</title>

<link rel='canonical' href='http://808Mak1r.github.io/p/test-post/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='试着去理解虚拟DOM'>
<meta property='og:description' content='试着去理解虚拟DOM'>
<meta property='og:url' content='http://808Mak1r.github.io/p/test-post/'>
<meta property='og:site_name' content='808Mak1r'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='前端' /><meta property='article:published_time' content='2019-04-12T10:41:20&#43;08:00'/><meta property='article:modified_time' content='2019-04-12T10:41:20&#43;08:00'/>
<meta name="twitter:title" content="试着去理解虚拟DOM">
<meta name="twitter:description" content="试着去理解虚拟DOM">
    </head>
    <body class="">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.body.dataset.scheme = 'dark';
        } else {
            document.body.dataset.scheme = 'light';
        }
    })();
</script><div class="container main-container flex on-phone--column extended article-page with-toolbar">
            <aside class="sidebar left-sidebar sticky">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header class="site-info">
        
            <figure class="site-avatar">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu639e11651d22d4499f5a1ba9543dc353_27179_300x0_resize_box_2.png" width="300"
                            height="301" class="site-logo" loading="lazy" alt="Avatar">
                    
                

                
                    <span class="emoji">🍥</span>
                
            </figure>
        
        <h1 class="site-name"><a href="http://808Mak1r.github.io">808Mak1r</a></h1>
        <h2 class="site-description">kekeke~~~</h2>
    </header>

    <ol class="menu" id="main-menu">
        
        
        

        <li >
            <a href='/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>Home</span>
            </a>
        </li>
        
        

        <li >
            <a href='/about'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>About</span>
            </a>
        </li>
        
        

        <li >
            <a href='/archives'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        

        <li >
            <a href='/search'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        

        
            <li id="dark-mode-toggle">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                <span>Dark Mode</span>
            </li>
        
    </ol>
</aside>

            <main class="main full-width">
    <div id="article-toolbar">
        <a href="http://808Mak1r.github.io" class="back-home">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



            <span>Back</span>
        </a>
    </div>

    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E5%89%8D%E7%AB%AF/" >
                前端
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/test-post/">常见DOM以及API总结</a>
    </h2>

    
    <h3 class="article-subtitle">
        常见DOM以及API总结
    </h3>
    <footer class="article-time">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <time class="article-time--published">Apr 12, 2019</time>
    </footer></div>
</header>

    <section class="article-content">
    <h1 id="dom">DOM</h1>
<p>DOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。</p>
<p>浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。</p>
<p>DOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最常见的任务，离开了 DOM，JavaScript 就无法控制网页。另一方面，JavaScript 也是最常用于 DOM 操作的语言。后面介绍的就是 JavaScript 对 DOM 标准的实现和用法。</p>
<h1 id="node-接口">Node 接口</h1>
<h2 id="nodeprototypenodetype">Node.prototype.nodeType</h2>
<p>nodeType属性返回一个整数值，表示节点的类型。</p>
<pre><code>document.nodeType // 9
</code></pre><p>上面代码中，文档节点的类型值为9。</p>
<p>Node 对象定义了几个常量，对应这些类型值。</p>
<pre><code>document.nodeType === Node.DOCUMENT_NODE // true
</code></pre><p>上面代码中，文档节点的nodeType属性等于常量Node.DOCUMENT_NODE。</p>
<p>不同节点的nodeType属性值和对应的常量如下。</p>
<ul>
<li>文档节点（document）：9，对应常量Node.DOCUMENT_NODE</li>
<li>元素节点（element）：1，对应常量Node.ELEMENT_NODE</li>
<li>属性节点（attr）：2，对应常量Node.ATTRIBUTE_NODE</li>
<li>文本节点（text）：3，对应常量Node.TEXT_NODE</li>
<li>文档片断节点（DocumentFragment）：11，对应常量Node.DOCUMENT_FRAGMENT_NODE</li>
<li>文档类型节点（DocumentType）：10，对应常量Node.DOCUMENT_TYPE_NODE</li>
<li>注释节点（Comment）：8，对应常量Node.COMMENT_NODE
确定节点类型时，使用nodeType属性是常用方法。</li>
</ul>
<pre><code>var node = document.documentElement.firstChild;
if (node.nodeType === Node.ELEMENT_NODE) {
  console.log('该节点是元素节点');
}
</code></pre><h2 id="nodeprototypenodename">Node.prototype.nodeName</h2>
<p>nodeName属性返回节点的名称。</p>
<pre><code>// HTML 代码如下
// &lt;div id=&quot;d1&quot;&gt;hello world&lt;/div&gt;
var div = document.getElementById('d1');
div.nodeName // &quot;DIV&quot;
</code></pre><p>上面代码中，元素节点<!-- raw HTML omitted -->的nodeName属性就是大写的标签名DIV。</p>
<p>不同节点的nodeName属性值如下。</p>
<ul>
<li>文档节点（document）：#document</li>
<li>元素节点（element）：大写的标签名</li>
<li>属性节点（attr）：属性的名称</li>
<li>文本节点（text）：#text</li>
<li>文档片断节点（DocumentFragment）：#document-fragment</li>
<li>文档类型节点（DocumentType）：文档的类型</li>
<li>注释节点（Comment）：#comment</li>
</ul>
<h2 id="nodeprototypenodevalue">Node.prototype.nodeValue</h2>
<p>nodeValue属性返回一个字符串，表示当前节点本身的文本值，该属性可读写。</p>
<p>只有文本节点（text）、注释节点（comment）和属性节点（attr）有文本值，因此这三类节点的nodeValue可以返回结果，其他类型的节点一律返回null。同样的，也只有这三类节点可以设置nodeValue属性的值，其他类型的节点设置无效。</p>
<pre><code>// HTML 代码如下
// &lt;div id=&quot;d1&quot;&gt;hello world&lt;/div&gt;
var div = document.getElementById('d1');
div.nodeValue // null
div.firstChild.nodeValue // &quot;hello world&quot;
</code></pre><p>上面代码中，div是元素节点，nodeValue属性返回null。div.firstChild是文本节点，所以可以返回文本值。</p>
<h2 id="nodeprototypetextcontent">Node.prototype.textContent</h2>
<p>textContent属性返回当前节点和它的所有后代节点的文本内容。</p>
<pre><code>// HTML 代码为
// &lt;div id=&quot;divA&quot;&gt;This is &lt;span&gt;some&lt;/span&gt; text&lt;/div&gt;

document.getElementById('divA').textContent
// This is some text
</code></pre><p>textContent属性自动忽略当前节点内部的 HTML 标签，返回所有文本内容。</p>
<p>该属性是可读写的，设置该属性的值，会用一个新的文本节点，替换所有原来的子节点。它还有一个好处，就是自动对 HTML 标签转义。这很适合用于用户提供的内容。</p>
<pre><code>document.getElementById('foo').textContent = '&lt;p&gt;GoodBye!&lt;/p&gt;';
</code></pre><p>上面代码在插入文本时，会将<!-- raw HTML omitted -->标签解释为文本，而不会当作标签处理。</p>
<p>对于文本节点（text）、注释节点（comment）和属性节点（attr），textContent属性的值与nodeValue属性相同。对于其他类型的节点，该属性会将每个子节点（不包括注释节点）的内容连接在一起返回。如果一个节点没有子节点，则返回空字符串。</p>
<p>文档节点（document）和文档类型节点（doctype）的textContent属性为null。如果要读取整个文档的内容，可以使用document.documentElement.textContent。</p>
<h2 id="nodeprototypebaseuri">Node.prototype.baseURI</h2>
<p>baseURI属性返回一个字符串，表示当前网页的绝对路径。浏览器根据这个属性，计算网页上的相对路径的 URL。该属性为只读。</p>
<pre><code>// 当前网页的网址为
// http://www.example.com/index.html
document.baseURI
// &quot;http://www.example.com/index.html&quot;
</code></pre><p>如果无法读到网页的 URL，baseURI属性返回null。</p>
<p>该属性的值一般由当前网址的 URL（即window.location属性）决定，但是可以使用 HTML 的<!-- raw HTML omitted -->标签，改变该属性的值。</p>
<pre><code>&lt;base href=&quot;http://www.example.com/page.html&quot;&gt;
</code></pre><p>设置了以后，baseURI属性就返回<!-- raw HTML omitted -->标签设置的值。</p>
<h2 id="nodeprototypeownerdocument">Node.prototype.ownerDocument</h2>
<p>Node.ownerDocument属性返回当前节点所在的顶层文档对象，即document对象。</p>
<pre><code>var d = p.ownerDocument;
d === document // true
</code></pre><p>document对象本身的ownerDocument属性，返回null。</p>
<h2 id="nodeprototypenextsibling">Node.prototype.nextSibling</h2>
<p>Node.nextSibling属性返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回null。</p>
<pre><code>// HTML 代码如下
// &lt;div id=&quot;d1&quot;&gt;hello&lt;/div&gt;&lt;div id=&quot;d2&quot;&gt;world&lt;/div&gt;
var d1 = document.getElementById('d1');
var d2 = document.getElementById('d2');

d1.nextSibling === d2 // true
</code></pre><p>上面代码中，d1.nextSibling就是紧跟在d1后面的同级节点d2。</p>
<p>注意，该属性还包括文本节点和注释节点（<!-- raw HTML omitted -->）。因此如果当前节点后面有空格，该属性会返回一个文本节点，内容为空格。</p>
<p>nextSibling属性可以用来遍历所有子节点。</p>
<pre><code>var el = document.getElementById('div1').firstChild;

while (el !== null) {
  console.log(el.nodeName);
  el = el.nextSibling;
}
</code></pre><p>上面代码遍历div1节点的所有子节点。</p>
<h1 id="nodelist-接口">NodeList 接口</h1>
<p>NodeList实例是一个类似数组的对象，它的成员是节点对象。通过以下方法可以得到NodeList实例。</p>
<ul>
<li>Node.childNodes</li>
<li>document.querySelectorAll()等节点搜索方法</li>
</ul>
<pre><code>document.body.childNodes instanceof NodeList // true
</code></pre><p>NodeList实例很像数组，可以使用length属性和forEach方法。但是，它不是数组，不能使用pop或push之类数组特有的方法。</p>
<pre><code>var children = document.body.childNodes;

Array.isArray(children) // false

children.length // 34
children.forEach(console.log)
</code></pre><p>上面代码中，NodeList 实例children不是数组，但是具有length属性和forEach方法。</p>
<p>如果NodeList实例要使用数组方法，可以将其转为真正的数组。</p>
<pre><code>var children = document.body.childNodes;
var nodeArr = Array.prototype.slice.call(children);
</code></pre><p>除了使用forEach方法遍历 NodeList 实例，还可以使用for循环。</p>
<pre><code>var children = document.body.childNodes;

for (var i = 0; i &lt; children.length; i++) {
  var item = children[i];
}
</code></pre><p>注意，NodeList 实例可能是动态集合，也可能是静态集合。所谓动态集合就是一个活的集合，DOM 删除或新增一个相关节点，都会立刻反映在 NodeList 实例。目前，只有Node.childNodes返回的是一个动态集合，其他的 NodeList 都是静态集合。</p>
<pre><code>var children = document.body.childNodes;
children.length // 18
document.body.appendChild(document.createElement('p'));
children.length // 19
</code></pre><p>上面代码中，文档增加一个子节点，NodeList 实例children的length属性就增加了1。</p>
<h2 id="nodelistprototypelength">NodeList.prototype.length</h2>
<p>length属性返回 NodeList 实例包含的节点数量。</p>
<pre><code>document.querySelectorAll('xxx').length
// 0
</code></pre><p>上面代码中，document.querySelectorAll返回一个 NodeList 集合。对于那些不存在的 HTML 标签，length属性返回0。</p>
<h2 id="nodelistprototypeforeach">NodeList.prototype.forEach()</h2>
<p>forEach方法用于遍历 NodeList 的所有成员。它接受一个回调函数作为参数，每一轮遍历就执行一次这个回调函数，用法与数组实例的forEach方法完全一致。</p>
<pre><code>var children = document.body.childNodes;
children.forEach(function f(item, i, list) {
  // ...
}, this);
</code></pre><p>上面代码中，回调函数f的三个参数依次是当前成员、位置和当前 NodeList 实例。forEach方法的第二个参数，用于绑定回调函数内部的this，该参数可省略。</p>
<h2 id="nodelistprototypeitem">NodeList.prototype.item()</h2>
<p>item方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。</p>
<pre><code>document.body.childNodes.item(0)
</code></pre><p>上面代码中，item(0)返回第一个成员。</p>
<p>如果参数值大于实际长度，或者索引不合法（比如负数），item方法返回null。如果省略参数，item方法会报错。</p>
<p>所有类似数组的对象，都可以使用方括号运算符取出成员。一般情况下，都是使用方括号运算符，而不使用item方法。</p>
<pre><code>document.body.childNodes[0]
</code></pre><h2 id="nodelistprototypekeysnodelistprototypevaluesnodelistprototypeentries">NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries()</h2>
<p>这三个方法都返回一个 ES6 的遍历器对象，可以通过for&hellip;of循环遍历获取每一个成员的信息。区别在于，keys()返回键名的遍历器，values()返回键值的遍历器，entries()返回的遍历器同时包含键名和键值的信息。</p>
<pre><code>var children = document.body.childNodes;

for (var key of children.keys()) {
  console.log(key);
}
// 0
// 1
// 2
// ...

for (var value of children.values()) {
  console.log(value);
}
// #text
// &lt;script&gt;
// ...

for (var entry of children.entries()) {
  console.log(entry);
}
// Array [ 0, #text ]
// Array [ 1, &lt;script&gt; ]
// ...
</code></pre><h1 id="parentnode-接口">ParentNode 接口</h1>
<p>如果当前节点是父节点，就会继承ParentNode接口。由于只有元素节点（element）、文档节点（document）和文档片段节点（documentFragment）拥有子节点，因此只有这三类节点会继承ParentNode接口。</p>
<h2 id="parentnodechildren">ParentNode.children</h2>
<p>children属性返回一个HTMLCollection实例，成员是当前节点的所有元素子节点。该属性只读。</p>
<p>下面是遍历某个节点的所有元素子节点的示例。</p>
<pre><code>for (var i = 0; i &lt; el.children.length; i++) {
  // ...
}
</code></pre><p>注意，children属性只包括元素子节点，不包括其他类型的子节点（比如文本子节点）。如果没有元素类型的子节点，返回值HTMLCollection实例的length属性为0。</p>
<p>另外，HTMLCollection是动态集合，会实时反映 DOM 的任何变化。</p>
<h2 id="parentnodefirstelementchild">ParentNode.firstElementChild</h2>
<p>firstElementChild属性返回当前节点的第一个元素子节点。如果没有任何元素子节点，则返回null。</p>
<pre><code>document.firstElementChild.nodeName
// &quot;HTML&quot;
</code></pre><p>上面代码中，document节点的第一个元素子节点是<!-- raw HTML omitted -->。</p>
<h2 id="parentnodelastelementchild">ParentNode.lastElementChild</h2>
<p>lastElementChild属性返回当前节点的最后一个元素子节点，如果不存在任何元素子节点，则返回null。</p>
<pre><code>document.lastElementChild.nodeName
// &quot;HTML&quot;
</code></pre><p>上面代码中，document节点的最后一个元素子节点是<!-- raw HTML omitted -->（因为document只包含这一个元素子节点）。</p>
<h2 id="parentnodechildelementcount">ParentNode.childElementCount</h2>
<p>childElementCount属性返回一个整数，表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点，则返回0。</p>
<pre><code>document.body.childElementCount // 13
ParentNode.append()，ParentNode.prepend()
</code></pre><p>append方法为当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面。</p>
<p>该方法不仅可以添加元素子节点，还可以添加文本子节点。</p>
<pre><code>var parent = document.body;

// 添加元素子节点
var p = document.createElement('p');
parent.append(p);

// 添加文本子节点
parent.append('Hello');

// 添加多个元素子节点
var p1 = document.createElement('p');
var p2 = document.createElement('p');
parent.append(p1, p2);

// 添加元素子节点和文本子节点
var p = document.createElement('p');
parent.append('Hello', p);
</code></pre><p>注意，该方法没有返回值。</p>
<p>prepend方法为当前节点追加一个或多个子节点，位置是第一个元素子节点的前面。它的用法与append方法完全一致，也是没有返回值。</p>
<h1 id="childnode-接口">ChildNode 接口</h1>
<p>remove方法用于从父节点移除当前节点。</p>
<pre><code>el.remove()
</code></pre><p>上面代码在 DOM 里面移除了el节点。</p>
<h2 id="childnodebeforechildnodeafter">ChildNode.before()，ChildNode.after()</h2>
<p>before方法用于在当前节点的前面，插入一个或多个同级节点。两者拥有相同的父节点。</p>
<p>注意，该方法不仅可以插入元素节点，还可以插入文本节点。</p>
<pre><code>var p = document.createElement('p');
var p1 = document.createElement('p');

// 插入元素节点
el.before(p);

// 插入文本节点
el.before('Hello');

// 插入多个元素节点
el.before(p, p1);

// 插入元素节点和文本节点
el.before(p, 'Hello');
</code></pre><p>after方法用于在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点。用法与before方法完全相同。</p>
<h2 id="childnodereplacewith">ChildNode.replaceWith()</h2>
<p>replaceWith方法使用参数节点，替换当前节点。参数可以是元素节点，也可以是文本节点。</p>
<pre><code>var span = document.createElement('span');
el.replaceWith(span);
</code></pre><p>上面代码中，el节点将被span节点替换。</p>
<h1 id="节点创建型api">节点创建型api</h1>
<p>在这里，我将常用的DOM操作api进行分类，首先要介绍的是创建型的api。这一类型的api，简而言之就是用来创建节点的。</p>
<h2 id="createelement"><strong>createElement</strong></h2>
<p>createElement通过传入指定的一个标签名来创建一个元素，如果传入的标签名是一个未知的，则会创建一个自定义的标签，注意：IE8以下浏览器不支持自定义标签。
使用如下：</p>
<pre><code>var div = document.createElement(&quot;div&quot;);
</code></pre><p>使用createElement要注意：通过createElement创建的元素并不属于html文档，它只是创建出来，并未添加到html文档中，要调用appendChild或insertBefore等方法将其添加到HTML文档树中。</p>
<h2 id="createtextnode"><strong>createTextNode</strong></h2>
<p>createTextNode用来创建一个文本节点，用法如下：</p>
<pre><code>var textNode = document.createTextNode(&quot;一个TextNode&quot;);
</code></pre><p>createTextNode接收一个参数，这个参数就是文本节点中的文本，和createElement一样，创建后的文本节点也只是独立的一个节点，同样需要appendChild将其添加到HTML文档树中</p>
<h2 id="clonenode">cloneNode</h2>
<p>cloneNode是用来返回调用方法的节点的一个副本，它接收一个bool参数，用来表示是否复制子元素，使用如下：</p>
<pre><code>var parent = document.getElementById(&quot;parentElement&quot;); 
var parent2 = parent.cloneNode(true);// 传入true
parent2.id = &quot;parent2&quot;;
</code></pre><p>这段代码通过cloneNode复制了一份parent元素，其中cloneNode的参数为true，表示parent的子节点也被复制，如果传入false，则表示只复制了parent节点。
我们看看这个例子</p>
<pre><code>&lt;div id=&quot;parent&quot;&gt;
    我是父元素的文本
    &lt;br/&gt;
    &lt;span&gt;
        我是子元素
    &lt;/span&gt;
&lt;/div&gt;
&lt;button id=&quot;btnCopy&quot;&gt;复制&lt;/button&gt;

var parent = document.getElementById(&quot;parent&quot;);
document.getElementById(&quot;btnCopy&quot;).onclick = function(){
	var parent2 = parent.cloneNode(true);
	parent2.id = &quot;parent2&quot;;
	document.body.appendChild(parent2);
}
</code></pre><p>这段代码很简单，主要是绑定button事件，事件内容是复制了一个parent，修改其id，然后添加到文档中。
这里有几点要注意：
（1）和createElement一样，cloneNode创建的节点只是游离有html文档外的节点，要调用appendChild方法才能添加到文档树中
（2）如果复制的元素有id，则其副本同样会包含该id，由于id具有唯一性，所以在复制节点后必须要修改其id
（3）调用接收的bool参数最好传入，如果不传入该参数，不同浏览器对其默认值的处理可能不同</p>
<p>除此之外，我们还有一个需要注意的点：
如果被复制的节点绑定了事件，则副本也会跟着绑定该事件吗？这里要分情况讨论：
（1）如果是通过addEventListener或者比如onclick进行绑定事件，则副本节点不会绑定该事件
（2）如果是内联方式绑定比如</p>
<pre><code>&lt;div onclick=&quot;showParent()&quot;&gt;&lt;/div&gt;
</code></pre><p>这样的话，副本节点同样会触发事件。</p>
<h2 id="createdocumentfragment">createDocumentFragment</h2>
<p>createDocumentFragment方法用来创建一个DocumentFragment。在前面我们说到DocumentFragment表示一种轻量级的文档，它的作用主要是存储临时的节点用来准备添加到文档中。
createDocumentFragment方法主要是用于添加大量节点到文档中时会使用到。假设要循环一组数据，然后创建多个节点添加到文档中，比如示例</p>
<pre><code>&lt;ul id=&quot;list&quot;&gt;&lt;/ul&gt;
&lt;input type=&quot;button&quot; value=&quot;添加多项&quot; id=&quot;btnAdd&quot; /&gt;

document.getElementById(&quot;btnAdd&quot;).onclick = function(){
	var list = document.getElementById(&quot;list&quot;);
	for(var i = 0;i &lt; 100; i++){
		var li = document.createElement(&quot;li&quot;);
		li.textContent = i;
		list.appendChild(li);
	}
}
</code></pre><p>这段代码将按钮绑定了一个事件，这个事件创建了100个li节点，然后依次将其添加HTML文档中。这样做有一个缺点：每次一创建一个新的元素，然后添加到文档树中，这个过程会造成浏览器的回流。所谓回流简单说就是指元素大小和位置会被重新计算，如果添加的元素太多，会造成性能问题。这个时候，就是使用createDocumentFragment了。
DocumentFragment不是文档树的一部分，它是保存在内存中的，所以不会造成回流问题。我们修改上面的代码如下：</p>
<pre><code>document.getElementById(&quot;btnAdd&quot;).onclick = function(){
	var list = document.getElementById(&quot;list&quot;);	
	var fragment = document.createDocumentFragment();

	for(var i = 0;i &lt; 100; i++){
	  var li = document.createElement(&quot;li&quot;);
		li.textContent = i;
		fragment.appendChild(li);
	}

	list.appendChild(fragment);
}
</code></pre><p>优化后的代码主要是创建了一个fragment，每次生成的li节点先添加到fragment，最后一次性添加到list，大家可以看示例</p>
<h2 id="创建型api总结">创建型API总结</h2>
<p>创建型api主要包括createElement，createTextNode，cloneNode和createDocumentFragment四个方法，需要注意下面几点：</p>
<ol>
<li>它们创建的节点只是一个孤立的节点，要通过appendChild添加到文档中</li>
<li>cloneNode要注意如果被复制的节点是否包含子节点以及事件绑定等问题</li>
<li>使用createDocumentFragment来解决添加大量节点时的性能问题</li>
</ol>
<h1 id="页面修改型api">页面修改型API</h1>
<p>前面我们提到创建型api，它们只是创建节点，并没有真正修改到页面内容，而是要调用appendChild来将其添加到文档树中。我在这里将这类会修改到页面内容归为一类。
修改页面内容的api主要包括：appendChild，insertBefore，removeChild，replaceChild。</p>
<h2 id="appendchild">appendChild</h2>
<p>appendChild我们在前面已经用到多次，就是将指定的节点添加到调用该方法的节点的子元素的末尾。调用方法如下：</p>
<pre><code>parent.appendChild(child);
</code></pre><p>child节点将会作为parent节点的最后一个子节点。
appendChild这个方法很简单，但是还有有一点需要注意：如果被添加的节点是一个页面中存在的节点，则执行后这个节点将会添加到指定位置，其原本所在的位置将移除该节点，也就是说不会同时存在两个该节点在页面上，相当于把这个节点移动到另一个地方。我们来看例子</p>
<pre><code>&lt;div id=&quot;child&quot;&gt;
    要被添加的节点
&lt;/div&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;div id=&quot;parent&quot;&gt;
    要移动的位置
&lt;/div&gt;		
&lt;input id=&quot;btnMove&quot; type=&quot;button&quot; value=&quot;移动节点&quot; /&gt;

document.getElementById(&quot;btnMove&quot;).onclick = function(){
	var child = document.getElementById(&quot;child&quot;);
	document.getElementById(&quot;parent&quot;).appendChild(child);
}
</code></pre><p>这段代码主要是获取页面上的child节点，然后添加到指定位置，可以看到原本的child节点被移动到parent中了。
这里还有一个要注意的点：如果child绑定了事件，被移动时，它依然绑定着该事件。</p>
<h2 id="insertbefore">insertBefore</h2>
<p>insertBefore用来添加一个节点到一个参照节点之前，用法如下：</p>
<pre><code>parentNode.insertBefore(newNode,refNode);
</code></pre><p>parentNode表示新节点被添加后的父节点
newNode表示要添加的节点
refNode表示参照节点，新节点会添加到这个节点之前
我们来看这个例子</p>
<pre><code>&lt;div id=&quot;parent&quot;&gt;
    父节点
    &lt;div id=&quot;child&quot;&gt;				
        子元素
    &lt;/div&gt;
&lt;/div&gt;
&lt;input type=&quot;button&quot; id=&quot;insertNode&quot; value=&quot;插入节点&quot; /&gt;

var parent = document.getElementById(&quot;parent&quot;);
var child = document.getElementById(&quot;child&quot;);
document.getElementById(&quot;insertNode&quot;).onclick = function(){
	var newNode = document.createElement(&quot;div&quot;);
	newNode.textContent = &quot;新节点&quot;
	parent.insertBefore(newNode,child);
}
</code></pre><p>这段代码创建了一个新节点，然后添加到child节点之前。
和appendChild一样，如果插入的节点是页面上的节点，则会移动该节点到指定位置，并且保留其绑定的事件。</p>
<p>关于第二个参数参照节点还有几个注意的地方：</p>
<ol>
<li>refNode是必传的，如果不传该参数会报错</li>
<li>如果refNode是undefined或null，则insertBefore会将节点添加到子元素的末尾</li>
</ol>
<h2 id="removechild">removeChild</h2>
<p>removeChild顾名思义，就是删除指定的子节点并返回，用法如下：</p>
<pre><code>var deletedChild = parent.removeChild(node);
</code></pre><p>deletedChild指向被删除节点的引用，它等于node，被删除的节点仍然存在于内存中，可以对其进行下一步操作。
注意：如果被删除的节点不是其子节点，则程序将会报错。我们可以通过下面的方式来确保可以删除：</p>
<pre><code>if(node.parentNode){
    node.parentNode.removeChild(node);
}
</code></pre><p>通过节点自己获取节点的父节点，然后将自身删除。</p>
<h2 id="replacechild">replaceChild</h2>
<p>replaceChild用于使用一个节点替换另一个节点，用法如下</p>
<pre><code>parent.replaceChild(newChild,oldChild);
</code></pre><p>newChild是替换的节点，可以是新的节点，也可以是页面上的节点，如果是页面上的节点，则其将被转移到新的位置
oldChild是被替换的节点</p>
<p>页面修改型API总结
页面修改型api主要是这四个接口，要注意几个特点：</p>
<ol>
<li>不管是新增还是替换节点，如果新增或替换的节点是原本存在页面上的，则其原来位置的节点将被移除，也就是说同一个节点不能存在于页面的多个位置</li>
<li>节点本身绑定的事件会不会消失，会一直保留着。</li>
</ol>
<h1 id="节点查询型api">节点查询型API</h1>
<p>节点查询型API也是非常常用的api，下面我们分别说明一下每一个api的使用。</p>
<h2 id="documentgetelementbyid">document.getElementById</h2>
<p>这个接口很简单，根据元素id返回元素，返回值是Element类型，如果不存在该元素，则返回null。
使用这个接口有几点要注意：</p>
<ol>
<li>元素的Id是大小写敏感的，一定要写对元素的id</li>
<li>HTML文档中可能存在多个id相同的元素，则返回第一个元素</li>
<li>只从文档中进行搜索元素，如果创建了一个元素并指定id，但并没有添加到文档中，则这个元素是不会被查找到的</li>
</ol>
<h2 id="documentgetelementsbytagname">document.getElementsByTagName</h2>
<p>这个接口根据元素标签名获取元素，返回一个即时的HTMLCollection类型，什么是即时的HTMLCollection类型呢？我们来看看这个示例</p>
<pre><code>&lt;div&gt;div1&lt;/div&gt;
&lt;div&gt;div2&lt;/div&gt;
		
&lt;input type=&quot;button&quot; value=&quot;显示数量&quot; id=&quot;btnShowCount&quot;/&gt;
&lt;input type=&quot;button&quot; value=&quot;新增div&quot; id=&quot;btnAddDiv&quot;/&gt;	

var divList = document.getElementsByTagName(&quot;div&quot;);
document.getElementById(&quot;btnAddDiv&quot;).onclick = function(){
	var div = document.createElement(&quot;div&quot;);
	div.textContent =&quot;div&quot; + (divList.length+1);
	document.body.appendChild(div);
}
	
document.getElementById(&quot;btnShowCount&quot;).onclick = function(){
        alert(divList.length);
}
</code></pre><p>这段代码中有两个按钮，一个按钮是显示HTMLCollection元素的个数，另一个按钮可以新增一个div标签到文档中。前面提到HTMLCollcetion元素是即时的表示该集合是随时变化的，也就是是文档中有几个div，它会随时进行变化，当我们新增一个div后，再访问HTMLCollection时，就会包含这个新增的div。
使用document.getElementsByTagName这个方法有几点要注意：</p>
<ol>
<li>如果要对HTMLCollection集合进行循环操作，最好将其长度缓存起来，因为每次循环都会去计算长度，暂时缓存起来可以提高效率</li>
<li>如果没有存在指定的标签，该接口返回的不是null，而是一个空的HTMLCollection</li>
<li>“*”表示所有标签</li>
</ol>
<h2 id="documentgetelementsbyname">document.getElementsByName</h2>
<p>getElementsByName主要是通过指定的name属性来获取元素，它返回一个即时的NodeList对象。
使用这个接口主要要注意几点：</p>
<ol>
<li>返回对象是一个即时的NodeList，它是随时变化的</li>
<li>在HTML元素中，并不是所有元素都有name属性，比如div是没有name属性的，但是如果强制设置div的name属性，它也是可以被查找到的</li>
<li>在IE中，如果id设置成某个值，然后传入getElementsByName的参数值和id值一样，则这个元素是会被找到的，所以最好不好设置同样的值给id和name</li>
</ol>
<h2 id="documentgetelementsbyclassname">document.getElementsByClassName</h2>
<p>这个API是根据元素的class返回一个即时的HTMLCollection，用法如下</p>
<pre><code>var elements = document.getElementsByClassName(names);
</code></pre><p>这个接口有下面几点要注意：</p>
<ol>
<li>返回结果是一个即时的HTMLCollection，会随时根据文档结构变化</li>
<li>IE9以下浏览器不支持</li>
<li>如果要获取2个以上classname，可传入多个classname，每个用空格相隔，例如</li>
</ol>
<pre><code>var elements = document.getElementsByClassName(&quot;test1 test2&quot;);
</code></pre><p>document.querySelector和document.querySelectorAll
这两个api很相似，通过css选择器来查找元素，注意选择器要符合CSS选择器的规则。
首先来介绍一下document.querySelector。
document.querySelector返回第一个匹配的元素，如果没有匹配的元素，则返回null。
注意，由于返回的是第一个匹配的元素，这个api使用的深度优先搜索来获取元素。我们来看这个例子：</p>
<pre><code>&lt;div&gt;
    &lt;div&gt;
        &lt;span class=&quot;test&quot;&gt;第三级的span&lt;/span&gt;	
    &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;test&quot;&gt;			
    同级的第二个div
&lt;/div&gt;
&lt;input type=&quot;button&quot; id=&quot;btnGet&quot; value=&quot;获取test元素&quot; /&gt;

document.getElementById(&quot;btnGet&quot;).addEventListener(&quot;click&quot;,function(){
	var element = document.querySelector(&quot;.test&quot;);
	alert(element.textContent);
})
</code></pre><p>这个例子很简单，就是两个class都包含“test”的元素，一个在文档树的前面，但是它在第三级，另一个在文档树的后面，但它在第一级，通过querySelector获取元素时，它通过深度优先搜索，拿到文档树前面的第三级的元素。</p>
<p>document.querySelectorAll的不同之处在于它返回的是所有匹配的元素，而且可以匹配多个选择符，我们来看看下面这个例子</p>
<pre><code>&lt;div class=&quot;test&quot;&gt;
    class为test
&lt;/div&gt;
&lt;div id=&quot;test&quot;&gt;
    id为test
&lt;/div&gt;
&lt;input id=&quot;btnShow&quot; type=&quot;button&quot; value=&quot;显示内容&quot; /&gt;

document.getElementById(&quot;btnShow&quot;).addEventListener(&quot;click&quot;,function(){
	var elements = document.querySelectorAll(&quot;#test,.test&quot;);	
	for(var i = 0,length = elements.length;i&lt;length;i++){
		alert(elements[i].textContent);
	}	
})
</code></pre><p>这段代码通过querySelectorAll，使用id选择器和class选择器选择了两个元素，并依次输出其内容。要注意两点：
（1）querySelectorAll也是通过深度优先搜索，搜索的元素顺序和选择器的顺序无关
（2）返回的是一个非即时的NodeList，也就是说结果不会随着文档树的变化而变化</p>
<p>兼容性问题：querySelector和querySelectorAll在ie8以下的浏览器不支持。</p>
<h1 id="节点关系型api">节点关系型api</h1>
<p>在html文档中的每个节点之间的关系都可以看成是家谱关系，包含父子关系，兄弟关系等等，下面我们依次来看看每一种关系。</p>
<h2 id="父关系型api">父关系型api</h2>
<ul>
<li>parentNode：每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment。</li>
<li>parentElement：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element，如果不是，则返回null</li>
</ul>
<h2 id="兄弟关系型api">兄弟关系型api</h2>
<ul>
<li>
<p>previousSibling：节点的前一个节点，如果该节点是第一个节点，则为null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。</p>
</li>
<li>
<p>previousElementSibling：返回前一个元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持。</p>
</li>
<li>
<p>nextSibling：节点的后一个节点，如果该节点是最后一个节点，则为null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下。</p>
</li>
<li>
<p>nextElementSibling：返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。</p>
</li>
</ul>
<h2 id="子关系型api">子关系型api</h2>
<ul>
<li>childNodes：返回一个即时的NodeList，表示元素的子节点列表，子节点可能会包含文本节点，注释节点等。</li>
<li>children：一个即时的HTMLCollection，子节点都是Element，IE9以下浏览器不支持。</li>
<li>firstNode：第一个子节点</li>
<li>lastNode：最后一个子节点</li>
<li>hasChildNodes方法：可以用来判断是否包含子节点。</li>
</ul>
<h1 id="元素属性型api">元素属性型api</h1>
<h2 id="setattribute">setAttribute</h2>
<p>setAttribute：根据名称和值修改元素的特性，用法如下。</p>
<pre><code>element.setAttribute(name, value);
</code></pre><p>其中name是特性名，value是特性值。如果元素不包含该特性，则会创建该特性并赋值。
如果元素本身包含指定的特性名为属性，则可以世界访问属性进行赋值，比如下面两条代码是等价的：</p>
<pre><code>element.setAttribute(&quot;id&quot;,&quot;test&quot;);

element.id = &quot;test&quot;;
</code></pre><h2 id="getattribute">getAttribute</h2>
<p>getAttribute返回指定的特性名相应的特性值，如果不存在，则返回null或空字符串。用法如下：</p>
<pre><code>var value = element.getAttribute(&quot;id&quot;);
</code></pre><h1 id="元素样式型api">元素样式型api</h1>
<h2 id="windowgetcomputedstyle">window.getComputedStyle</h2>
<p>window.getComputedStyle是用来获取应用到元素后的样式，假设某个元素并未设置高度而是通过其内容将其高度撑开，这时候要获取它的高度就要用到getComputedStyle，用法如下：</p>
<pre><code>var style = window.getComputedStyle(element[, pseudoElt]);
</code></pre><p>element是要获取的元素，pseudoElt指定一个伪元素进行匹配。
返回的style是一个CSSStyleDeclaration对象。
通过style可以访问到元素计算后的样式</p>
<h2 id="getboundingclientrect">getBoundingClientRect</h2>
<p>getBoundingClientRect用来返回元素的大小以及相对于浏览器可视窗口的位置，用法如下：</p>
<pre><code>var clientRect = element.getBoundingClientRect();
</code></pre><p>clientRect是一个DOMRect对象，包含left，top，right，bottom，它是相对于可视窗口的距离，滚动位置发生改变时，它们的值是会发生变化的。除了IE9以下浏览器，还包含元素的height和width等数据，具体可查看链接。</p>
<h1 id="参考资料"><strong>参考资料</strong></h1>
<ul>
<li>阮一峰：<a class="link" href="https://wangdoc.com/javascript/dom/index.html"  target="_blank" rel="noopener"
    >JavaScript教程</a></li>
<li>狼狼的蓝胖子：<a class="link" href="http://luopq.com/2015/11/30/javascript-dom/"  target="_blank" rel="noopener"
    >Javascript操作DOM常用API总结</a></li>
</ul>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E5%89%8D%E7%AB%AF/">前端</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>

    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">Related contents</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/p/test-post/">
        
        

        <div class="article-details">
            <h2 class="article-title">试着去理解虚拟DOM</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/cookie%E6%98%AF%E4%BB%80%E4%B9%88/">
        
        

        <div class="article-details">
            <h2 class="article-title">Cookie是什么</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/js%E9%AB%98%E7%BA%A7%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/">
        
        

        <div class="article-details">
            <h2 class="article-title">JS高级基础知识小结</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%B0%8F%E8%AE%A1/">
        
        

        <div class="article-details">
            <h2 class="article-title">面试题小计</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E7%89%88jquery/">
        
        

        <div class="article-details">
            <h2 class="article-title">自己写一个简版jQuery</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>


    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2019 - 
        
        2021 808Mak1r
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="2.0.1">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css">
            </main>
        </div>
        <script src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"
    integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin="anonymous"></script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
